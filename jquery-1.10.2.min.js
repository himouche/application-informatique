/ *! jQuery v1.10.2 | (c) 2005, 2013 jQuery Foundation, Inc. | jquery.org/license
// @ sourceMappingURL = jquery-1.10.2.min.map
* /
(fonction (e, t) {var n, r, i = typede t, o = e.location, a = e.document, s = a.documentElement, l = e.jQuery, u = e. $, c = {}, p = [], f = "1.10.2", d = concatat, h = p.push, g = p. Slice, m = p.indexOf, y = c.toString, v = c. hasOwnProperty, b = f.trim, x = fonction (e, t) {retourne un nouveau x.fn.init (e, t, r)}, w = / [+ -]? (?: \ d * \. | ) \ d + (?: [eE] [+ -]? \ d + |) /. source, T = / \ S + / g, C = / ^ [\ s \ uFFE \ xA0] + | [\ s \ uFFE \ xA0] + $ / g, N = / ^ (?: \ s * (<[\ w \ W] +>) [^>] * | # ([\ w -] *)) $ /, k = / ^ <(\ w +) \ s * \ /?> (?: <\ / \ 1> |) $ /, E = / ^ [\],: {} \ s] * $ /, S = / (? : ^ |: |,) (?: \ s * \ [) + / g, A = / \\ (?: ["\\\ / bfnrt] | u [\ da-fA-F] {4}) /g,j=/"[^"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\????????\\\\\\\\\\\\\\\\\\\\\\ '? \ d + |) / g, D = / ^ - ms - /, L = / - ([\ da-z]) / gi, H = fonction (e, t) {retourne t.toUpperCase ()}, q = function (e) {(a.addEventListener || "load" === e.type || "complete" === a.readyState) && (_ (), x.ready ())}, _ = fonction ( ) {a.addEventListener? (a.removeEventListener ("DOMContentLoaded", q,! 1), e.removeEventListener ("load", q,! 1)) :( a.detachEvent ("onreadystatechange", q), e.detachEvent ("onload", q)) }; x.fn = x.prototype = {jquery: f, constructeur: x, init: fonction (e, n, r) {var i, o; if (! e) retourne ceci; if ("string" == typeof e) {if (i = "<" === e.charAt (0) && ">" === e.charAt (e.length-1) && e.length> = 3? [null, e, null ]: N.exec (e),! I ||! I [1] && n) return! N || n.jquery? (N || r) .find (e): this.constructor (n) .find ( e); si (i [1]) {si (n = n instance de x? n [0]: n, x.merge (this, x.parseHTML (i [1], n && n.nodeType? n.ownerDocument || n: a,! 0)), k.test (i [1]) && x.isPlainObject (n)) pour (i en n) x.isFunction (this [i])? this [i] (n [i] ): this.attr (i, n [i]); renvoie ceci} if (o = a.getElementById (i [2]), o && o.parentNode) {if (o.id! == i [2]) renvoie r.find (e); this.length = 1,this [0] = o} renvoie this.context = a, this.selector = e, this} renvoie e.nodeType? (this.context = this [0] = e, this.length = 1, this): x. isFunction (e)? r.ready (e) :( e.selector! == t && (this.selector = e.selector, this.context = e.context), x.makeArray (e, this))}, sélecteur : "", longueur: 0, toArray: function () {return g.call (this)}, get: function (e) {return null == e? this.toArray (): 0> e? this [this. longueur + e]: ceci [e]}, pushStack: fonction (e) {var t = x.merge (this.constructor (), e); retourne t.prevObject = this, t.context = this.context, t }, each: function (e, t) {return x.each (this, e, t)}, ready: function (e) {return x.ready.promise (). done (e), this}, tranche: function () {return this.pushStack (g.apply (this, arguments))}, premier: function () {retournera this.eq (0)}, dernier: function () {retournera this.eq (-1)} , eq: function (e) {var t = this.length, n = + e + (0> e? t: 0); renvoie this.pushStack (n> = 0 && t> n? [this [n]]: [] )},carte:function (e) {return this.pushStack (x.map (this, function (t, n) {return e.call (t, n, t)}))}, end: function () {return this.prevObject | | this.constructor (null)}, push: h, tri: []. sort, épissure: []. épissure}, x.fn.init.prototype = x.fn, x.extend = x.fn.extend = function () {var e, n, r, i, o, a, s = arguments [0] || {}, l = 1, u = arguments.length, c =! 1; pour ("booléen" == typeof s && (c = s, s = arguments [1] || {}, l = 2), "objet" == typeof s || x.isFonction (s) || (s = {}), u == = l && (s = ceci, - l); u> l; l ++) si (null! = (o = arguments [l])) pour (i dans o) e = s [i], r = o [i ], s! == r && (c && r && (x.isPlainObject (r) || (n = x.isArray (r)))? (n? (n =! 1, a = e && x.isArray (e)? e: []): a = e && x.isPlainObject (e)? e: {}, s [i] = x.extend (c, a, r)): r! == t && (s [i] = r)); renvoyer s}, x.extend ({expando: "jQuery" + (f + Math.random ()). replace (/ \ D / g, ""), noConflict: function (t) {retour e. $ == = x && (e. $ = u), t && e.jQuery === x && (e.jQuery = l), x}, isReady:! 1, readyWait: 1, holdReady: function (e) {e? x.readyWait ++: x .ready (! 0)}, prêt: function (e) {if (e ===! 0?! - x.readyWait:! x.isReady) {if (! a.body) renvoie setTimeout (x.ready ); x.isReady =! 0, e! ==! 0 && - x.readyWait> 0 || (n.resolveWith (a, [x]), x.fn.trigger && x (a) .trigger ("ready" ) .off ("ready"))}}, isFunction: fonction (e) {return "function" === x.type (e)}, isArray: Array.isArray || function (e) {return "tableau" === x.type (e)}, isWindow: fonction (e) {return null! = e && e == e.window}, isNumeric: fonction (e) {return! isNaN (parseFloat (e)) && isFinite (e) }, type: fonction (e) {retour null == e? e + "": "objet" == typedee || "fonction" == typee de e? c [y.call (e)] || "objet" : typeof e}, isPlainObject: function (e) {var n; if (! e || "objet"! == x.type (e) || e.nodeType || x.isWindow (e)) return {1; try {if (e.constructor &&! v.call (e, "constructeur") &&! v.call (e.constructor. prototype, "isPrototypeOf")) return! 1} catch (r) {return! 1} if (x.support.ownLast) pour (n dans e) renvoie v.call (e, n); pour (n dans e) ; return n === t || v.call (e, n)}, isEmptyObject: function (e) {var t; pour (t dans e) return! 1; return! 0}, erreur: function (e) {throw Error (e)}, parseHTML: function (e, t, n) {if (! e || "chaîne"! = typeof e) renvoie null; "boolean" == typeof t && (n = t, t = ! 1), t = t || a; var r = k.exec (e), i =! N && []; retourne r? [T.createElement (r [1])] :( r = x.buildFragment ( [e], t, i), i && x (i) .remove (), x.merge ([], r.childNodes))}, parseJSON: fonction (n) {return e.JSON && e.JSON.parse? e. JSON.parse (n): null === n? N: "chaîne" == typede n && (n = x.trim (n), n && E.test (n.replace (A, "@"). Remplacer (j ,"]"). remplacer (S, "")))? Fonction ("return" + n) () :( x.error ("JSON invalide:" + n), t)}, parseXML: function (n) {var r, i; if (! n || "chaîne"! = typeof n) retourne null; essayez {e.DOMParser? (i = nouveau DOMParser, r = i.parseFromString (n, "text / xml")) : (r = new ActiveXObject ("Microsoft.XMLDOM"), r.async = "false", r.loadXML (n))} catch (o) {r = t} renvoyer r && r.documentElement &&! r.getElementsByTagName ("parsererror ") .length || x.error (" XML invalide: "+ n), r}, noop: fonction () {}, globalEval: fonction (t) {t && x.trim (t) && (e.execScript || fonction (t) {e.eval.call (e, t)}) (t)}, camelCase: fonction (e) {retour e.replace (D, "ms -"). remplacer (L, H)}, nodeName: function (e, t) {return e.nodeName && e.nodeName.toLowerCase () === t.toLowerCase ()}, chaque: fonction (e, t, n) {var r, i = 0, o = e longueur, a = M (e);si (n) {si (a) {pour (; o> i; i ++) si (r = t.apply (e [i], n), r ===! 1) break} else pour (i in e ) si (r = t.apply (e [i], n), r ===! 1) casse} sinon si (a) {pour (; o> i; i ++) si (r = t.call (e [i], i, e [i]), r ===! 1) pause} sinon pour (i dans e) si (r = t.call (e [i], i, e [i]), r ===! 1) pause; retour e}, trim: b &&! B.call ("\ ufeff \ u00a0")? Fonction (e) {retour null == e? "": B.call (e)}: fonction (e) {retour null == e? "" :( e + ""). remplacer (C, "")}, makeArray: fonction (e, t) {var n = t || []; retour null! = e && (M (Object (e))? x.merge (n, "chaîne" == typede e? [e]: e): h.call (n, e)), n}, inArray: fonction (e , t, n) {var r; if (t) {if (m) renvoie m.call (t, e, n); for (r = t.length, n = n? 0> n? Math.max ( 0, r + n): n: 0; r> n; n ++) si (n dans t && t [n] === e) retourne n} retour-1}, fusionne: fonction (e, n) {var r = n.longueur, i = e.longueur, o = 0; if ("nombre" == typede r) pour (; r> o; o ++) e [i ++] = n [o]; sinon tout le temps (n [o] !== t) e [i ++] = n [o ++]; retourne e.length = i, e}, grep: fonction (e, t, n) {varr, i = [], o = 0, a = e .length; for (n = !! n; a> o; o ++) r = !! t (e [o], o), n! == r && i.push (e [o]); retourne i}, carte : fonction (e, t, n) {var r, i = 0, o = longueur e, a = M (e), s = []; si (a) pour (; o> i; i ++) r = t (e [i], i, n), null! = r && (s [longueur s]] = r); sinon pour (i dans e) r = t (e [i], i, n), null! = r && (s [longueur. s]] = r); return d.apply ([], s)}, guid: 1, proxy: fonction (e, n) {var r, i, o; retourne "chaîne" = = typede n && (o = e [n], n = e, e = o), x.isFonction (e)? (r = g.call (arguments, 2), i = fonction () {retour e.apply ( n || this, r.concat (g.call (arguments)))}, i.guid = e.guid = e.guid || x.guid ++, i): t}, accès: fonction (e, n, r, i, o, a, s) {var l = 0, u = longueur.e, longueur = c = null == r; si ("objet" === x.type (r)) {o =! 0; pour (l dans r) x.access (e, n, l, r [l],! 0, a, s)} sinon si (i! == t && (o =! 0, x.isFunction (i) | | (s =! 0), c && (s? (n.call (e, i), n = null) :( c = n, n = fonction (e, t,n) {retourne c.call (x (e), n)})), n)) pour (; u> l; l ++) n (e [l], r, s? i: i.call (e [ l], l, n (e [l], r))); retourne o? e: c? n.call (e): u? n (e [0], r): a}, maintenant: fonction ( ) {retourne (nouvelle date) .getTime ()}, échange: fonction (e, t, n, r) {var i, o, a = {}; pour (o in t) a [o] = e.style [o], e.style [o] = t [o]; i = n.apply (e, r || []); pour (o dans t) e.style [o] = a [o]; retour i}}), x.ready.promise = fonction (t) {if (! n) if (n = x.Deferred (), "complete" === a.readyState) setTimeout (x.ready), sinon si (a.addEventListener) a.addEventListener ("DOMContentLoaded", q,! 1), e.addEventListener ("load", q,! 1); else {a.attachEvent ("onreadystatechange", q), e.attachEvent ( "onload", q); var r =! 1; essayez {r = null == e.frameElement && a.documentElement} catch (i) {} r && r.doScroll && function o () {if (! x.isReady) {try {r .doScroll ("left")} catch (e) {return setTimeout (o, 50)} _ (), x.ready ()}} ()} retourne n.promise (t)}, x.each ("Boolean Number String Function Array Date RegExp Object Error" .split (""), fonction (e, t) {c ["[objet" + t + "]"] = t. toLowerCase ()}); fonction M (e) {var t = e.longueur, n = x.type (e); retourne x.isWindow (e)?! 1: 1 === e.nodeType && t?! 0: "tableau" === n || "fonction"! == n && (0 === t || "nombre" == typede t && t> 0 && t-1 dans e)} r = x (a), fonction (e, t) {var n, r, i, o, a, s, l, u, c, p, f, d, h, g, m, y, v, b = "grésillement" + - nouvelle date, w = e.document, T = 0, C = 0, N = st (), k = st (), E = st (), S =! 1, A = fonction (e, t) {retour e === t ? (S =! 0,0): 0}, j = typede t, D = 1 << 31, L = {}. HasOwnProperty, H = [], q = H.pop, _ = H.push, M = H.push, O = Hslice, F = H.indexOf || fonction (e) {var t = 0, n = this.length; pour (; n> t; t ++) si (this [t] = == e) retourne t; retourne-1}, B = "vérifié | sélectionné | asynchrone | autofocus | lecture automatique | contrôles | différer | désactivé | caché | ismap | boucle | multiple | ouvert | lu seulement | obligatoire | scoped ", P =" [\\ x20 \\ t \\ r \\ n \\ n \ \ f] ", R =" (?: \\\\. | [\\ w-] | [^ \\ x00 - \\ xa0]) + ", W = R.replace (" w "," w # "), $ =" \\ ["+ P +" * ("+ R +") "+ P +" * (?: ([* ^ $ |! ~]? =) "+ P +" * (? :( ['\ "]) ((?: \\\\. | [^ \\\\]) *?) \\ 3 | (" + W + ") |) |)" + P + "* \\]" , I = ":(" "+ R +") (?: \\ ((('' "")) ((?: \\\\. | [^ \\\\]) *?) \\ 3 | ((?: \\\\. | [^ \\\\ () [\\]] | "+ $. replace (3,8) +") *) |. *) \\) |) ", z = RegExp ("^" + P + "+ ((?: ^ | [^ \\\\]) (?: \\\\.) *)" + P + "+ $", "g"), X = RegExp ("^" + P + "*," + P + "*"), U = RegExp ("^" + P + "* ([> + ~] |" + P + ")" + P + "*") , V = RegExp (P + "* [+ ~]"), Y = RegExp ("= "+ P +" * ([^ \\] '\ "] *)" + P + "* \\]", "g"), J = RegExp (I), G = RegExp ("^" + W + " $ "), Q = {ID: RegExp (" ^ # ("+ R +") "), CLASSE: RegExp (" ^ \\. ("+ R +") "), TAG: RegExp (" ^ ("+ Remplacement ("w", "w *") + ")"), ATTR: RegExp ("^" + $), PSEUDO: RegExp ("^" + I), ENFANT: RegExp ("^ :( uniquement | first | last | nth | nth-last) - (enfant | de type) (?: \\ ("+ P +" * (pair | impair) (([+ -] |) (\\ d *) n |) "+ P +" * (?: ([+ -] |) "+ P +" * (\\ d +) |)) "+ P +" * \\) |) "," i "), bool: RegExp ("^ (?:" + B + ") $", "i"), needsContext: RegExp ("^" + P + "* [> + ~] |: (pair | impair | eq | gt | lt | nth | premier | dernier) (?: \\ ("+ P +" * ((?: - \\ d)? \\ d *) "+ P +" * \\) |) (? = [^ -] | $) "," i ")}, K = / ^ [^ {] + \ {\ s * \ [natif \ w /, Z = / ^ (?:# ([\ w -] +) | (\ w +) | \. ([\ w -] +)) $ /, et = / ^ (?: input | select | textarea | button) $ / i, tt = / ^ h \ d $ / i, nt = / '| \\ / g, rt = RegExp ("\\\\ ([\\ da-f] {1,6}" + P + "? | (" P + ") |.)", "Ig"), it = fonction (e, t, n) {var r = "0x" + t-65536; retourne r! == r || n? T: 0> r ? String.fromCharCode (r + 65536): String.fromCharCode (55296 | r >> 10,56320 | 1023 & r)}; essayez {M.apply (H = O.call (w.childNodes), w.childNodes), H [w.childNodes.length] .nodeType} catch (ot) {M = {appliquer: H.length? fonction (e, t) {_. apply (e, O.call (t))}: fonction (e, t) {var n = longueur e, r = 0; tandis que (e [n ++] = t [r ++]); e. longueur = n-1}}} fonction en (e, t, n, i) {var o, a, s, l, u, c, d, m, y, x; if ((t? t.ownerDocument || t: w)! == f && p (t), t = t || f, n = n || [],! e || "chaîne"! = typeof e) retourne n; si (1! == (l = t.nodeType) && 9! == l) retourne []; if (h &&!! i ) {si (o = Z.exec (e)) si (s = o [1]) {si (9 === l) {si (a = t.getElementById (s) ,! a ||! a.parentNode) return n; if (a.id === s) renvoie n.push (a), n} else if (t.ownerDocument && (a = t.ownerDocument.getElementById (s)) && v (t, a) && a .id === s) retourne n.push (a), n} sinon {if (o [2]) retourne M.apply (n, t.getElementsByTagName (e)), n; si ((s = o [ 3]) && r.getElementsByClassName && t.getElementsByClassName) renvoie M.apply (n, t.getElementsByClassName (s)), n} if (r.qsa && (! G ||! G.test (e))) (if) d = b, y = t, x = 9 === l && e, 1 === l && "objet"! == t.nodeNome.toLowerCase ()) {c = mt (e), (d = t.getAttribute ( "id")?? m = d.replace (nt, "\\ $ &"): t.setAttribute ("id", m), m = "[id = '" + m + "']", u = c.longueur; tandis que (u-) c [u] = m + yt (c [u]); y = test V. (e) && t.parentNode || t, x = c.join (",") } if (x) try {return M.apply (n, y.querySelectorAll (x)), n} catch (T) {} enfin {d || t.removeAttribute ("id")}}} retourne kt (e.replace (z, "$ 1"), t, n, i)} fonction st () {var e = []; fonction t (n, r) {retourne e.push (n + = "">> o.cacheLength && delete t [e.shift ()], t [n] = r} retourne t} fonction lt (e) {retourne e [b] =! 0, e} fonction ut (e) { var t = f.createElement ("div"); try {return !! e (t)} catch (n) {return! 1} finally {t.parentNode && t.parentNode.removeChild (t), t = null}} fonction ct (e, t) {var n = e.split ("|"), r = e.longueur; tandis que (r -) o.attrHandle [n [r]] = t} fonction pt (e, t) {var n = t && e, r = n && 1 === e.nodeType && 1 === t.nodeType && (~ t.sourceIndex || D) - (~ e.sourceIndex || D); if (r) renvoie r; if ( n) while (n = n.nextSibling) if (n === t) retour-1; retour e? 1: -1} fonction ft (e) {fonction de retour (t) {var n = t.nodeNom.toLowerCase (); return "input" === n && t.type === e}} function dt (e) {return fonction (t) {var n = t.nodeNome.toLowerCase (); return ("entrée "=== n ||" bouton "=== n) && t.type === e}} fonction ht (e) {retour lt (fonction (t) {retour t = + t, lt (fonction (n , r) {var i, o = e ([], n.longueur, t), a = o.longueur; tandis que (a -) n [i = o [a]] && (n [i] =! (r [i] = n [i]))})})} s = at.isXML = fonction (e) {var t = e && (e.ownerDocument || e) .documentElement; retourne t? "HTML"! == t.nodeName:! 1}, r = at.support = {}, p = at.setDocument = fonction (e) {var n = e? e.ownerDocument || e: w, i = n.defaultView; return n! == f && 9 === n.nodeType && n.documentElement? (f = n, d = n.documentElement, h =! s (n), i && i.attachEvent && i! == i.top && i.attachEvent ("onbeforeunload", function () {p ()}), r.attributes = ut (fonction (e) {return e.className = "i",! e.getAttribute ("className")}), r.getElementsByTagName = ut (fonction ( e) {return e.appendChild (n.createComment ("")),! e.getElementsByTagName ("* "). length}), r.getElementsByClassName = ut (fonction (e) {return e.innerHTML =" <div class = 'a'> </ div> <div class = 'a i'> </ div> ", e.firstChild.className =" i ", 2 === e.getElementsByClassName (" i "). length}), r.getById = ut (fonction (e) {retour d.appendChild (e) .id = b,! n.getElementsByName ||! n.getElementsByName (b) .length}), r.getById? (o.find.ID = fonction (e, t) {if (typede t.getElementById! == j && h) { var n = t.getElementById (e); renvoyer n && n.parentNode? [n]: []}}, o.filter.ID = fonction (e) {var t = e.replace (rt, it); fonction de retour ( e) {return e.getAttribute ("id") === t}}) :( supprimez o.find.ID, o.filter.ID = fonction (e) {var t = e.replace (rt, it) ; fonction de retour (e) {var n = type de e.getAttributeNode! == j && e.getAttributeNode ("id"); valeur de retour n && n.value === t}}), o.find.TAG = r.getElementsByTagName? function (e, n) {retourne le type de n.getElementsByTagName! == j? n.getElementsByTagName (e): t}: fonction (e, t) {var n, r = [], i = 0, o = t.getElementsByTagName (e); if ("*" === e) {tant que (n = o [i ++]) 1 === n.nodeType && r.push (n); return r} return}, o.find .CLASS = r.getElementsByClassName && fonction (e, n) {retourne le type de n.getElementsByClassName! == j && h? N.getElementsByClassName (e): t}, m = [], g = [], (r.qsa = K.test (n.querySelectorAll)) && (ut (fonction (e) {e.innerHTML = "<select> <option selected = ''> </ option> </ select>", e.querySelectorAll ("[sélectionné]") .length || g.push ("\\ [" + P + "* (?: valeur |" + B + ")"), e.querySelectorAll (": vérifié"). length || g.push (": vérifié) ")}), ut (fonction (e) {var t = n.createElement (" entrée "); t.setAttribute (" type ","caché"), e.appendChild (t) .setAttribute ("t", ""), e.querySelectorAll ("[t ^ = '']"). length && g.push ("[* ^ $] =" + P + "* (?: '' | \" \ ")"), e.querySelectorAll (": activé"). Length || g.push (": activé", ": désactivé"), e.querySelectorAll (" * ,: x "), g.push (",. *: ")}), (r.matchesSelector = K.test (y = d.webkitMatchesSelector || d.mozMatchesSelector || d.oMatchesSelector || d. msMatchesSelector)) && ut (fonction (e) {r.disconnectedMatch = y.call (e, "div"), y.call (e, "[s! = '']: x"), m.push ("! = ", I)}), g = g.length && RegExp (g.join (" | ")), m = m.length && RegExp (m.join (" | ")), v = K.test (d.contains) || d.compareDocumentPosition? function (e, t) {var n = 9 === e.nodeType? e.documentElement: e, r = t && t.parentNode; return e === r ||! (! r || 1! == r.nodeType ||! (n.contient? n.contains (r): e.compareDocumentPosition && 16 & e.compareDocumentPosition (r)))}: fonction (e, t) {si (t) while (t = t.parentNode) si (t === e) retourne! 0; retourne! 1}, A = d.compareDocumentPosition? fonction (e, t) {if (e === t) retourne S =! 0,0; var i = t.compareDocumentPosition && e.compareDocumentPosition && e.compareDocumentPosition (t); retourne i? 1 & i ||! r.sortDetached && t.compareDocumentPosition (e) === i? e === n || v (w, e)? - 1: t === n || v (w, t)? 1: c? F.call (c, e) -F.call (c, t ): 0: 4 & i? -1: 1: e.compareDocumentPosition? -1: 1}: fonction (e, t) {varr, i = 0, o = e.parentNode, a = t.parentNode, s = [ e], l = [t]; si (e === t) retourne S =! 0,0; si (! o ||! a) retourne e === n? -1: t === n? 1: o? -1: a? 1: c? F.call (c, e) -F.call (c, t): 0; si (o === a) renvoie pt (e, t); r = e; while (r = r.parentNode) s.unshift (r); r = t; tandis que (r = r.parentNode) l.unshift (r); tandis que (s [i] === l [i] ) i ++;retourne i? pt (s [i], l [i]): s [i] === w? -1: l [i] === w? 1: 0}, n): f}, at. allumettes = fonction (e, t) {retourne à (e, null, nul, t)}, at.matchesSelector = fonction (e, t) {if ((e.ownerDocument || e)! == f && p (e) , t = t.replace (Y, "= '$ 1']"),! (! r.matchesSelector ||! h || m && m.test (t) || g && g.test (t))) try {var n = y.call (e, t); if (n || r.disconnectedMatch || e.document && 11! == e.document.nodeType) retourne n} catch (i) {} retourne à (t, f, null, [e]). length> 0}, at.contains = function (e, t) {return (e.ownerDocument || e)! == f && p (e), v (e, t)}, at.attr = fonction (e, n) {(e.ownerDocument || e)! == f && p (e); var i = o.attrHandle [n.toLowerCase ()], a = i && L.call (o.attrHandle, n.toLowerCase ())? i (e, n,! h): t; retourne un === t? r.attributes ||! h? e.getAttribute (n) :( a = e.getAttributeNode (n)) && a. spécifié? a.valeur: null: a}, at.error = fonction (e) {throw Erreur ("Erreur de syntaxe,expression non reconnue: "+ e)}, at.uniqueSort = fonction (e) {var t, n = [], i = 0, o = 0; if (S =! r.detectDuplicates, c =! r.sortStable && e. tranche (0), e.sort (A), S) {tant que (t = e [o ++]) t === e [o] && (i = n.push (o)); tant que (i--) e.splice (n [i], 1)} renvoie e}, a = at.getText = fonction (e) {var t, n = "", r = 0, i = e.nodeType; if (i) { if (1 === i || 9 === i || 11 === i) {if ("chaîne" == typede e.textContent) retourne e.textContent; pour (e = e.firstChild; e; e = e.nextSibling) n + = a (e)} sinon si (3 === i || 4 === i) retourne e.nodeValue} else pour (; t = e [r]; r ++) n + = a (t); return n}, o = at.selectors = {cacheLength: 50, createPseudo: lt, correspondance: Q, attrHandle: {}, recherche: {}, relative: {">": {dir: "parentNode" , d'abord:! 0}, "": {dir: "parentNode"}, "+": {dir: "previousSibling", d'abord:! 0}, "~": {dir: "previousSibling"}}, preFilter: {ATTR: fonction (e) {retourne e [1] = e [1].remplacer (rt, it), e [3] = (e [4] || e [5] || ""). remplacer (rt, it), "~ =" === e [2] && (e [3] = "" + e [3] + ""), e.slice (0,4)}, ENFANT: fonction (e) {retourne e [1] = e [1] .toLowerCase (), "nième "=== e [1] .lice (0,3)? (e [3] || at.error (e [0]), e [4] = + (e [4]? e [5] + (e [6] || 1): 2 * ("pair" === e [3] || "impair" === e [3])), e [5] = + (e [7] + e [8] || "impair" === e [3])): e [3] && at.error (e [0]), e}, PSEUDO: fonction (e) {var n, r =! e [5] && e [2]; return Q.CHILD.test (e [0])? Null: (e [3] && e [4]! == t? E [2] = e [4]: ​​r && J.test (r) && (n = mt (r,! 0)) && (n = r.indexOf (")", r.length-n) -r.length) && (e [0] = e [0]. tranche (0, n), e [2] = r.slice (0, n)), e.slice (0,3))}}, filtre: {TAG: function (e) {var t = e.remplace (rt, it) .toLowerCase (); return "*" === e? function () {return! 0}: function (e) {return e.nodeName && e.nodeName.toLowerCase () === t}}, CLASSE: fonction (e) {var t = N [e + ""]; retourne t || (t = RegExp ("(^ |" + P + ")" + e + "( "+ P +" | $) ")) && N (e, fonction (e) {retourne t.test (" chaîne "== typeof e.className && e.className || typeof e.getAttribute! == j && e.getAttribute (" class ") ||" ")})}, ATTR: fonction (e, t, n) {retour fonction (r) {var i = at.attr (r, e); retour null == i?"! = " === t: t? (i + = "", "=" === t? i === n: "! =" === t? i! == n: "^ =" === t ? n && 0 === i.indexOf (n): "* =" === t? n && i.indexOf (n)> - 1: "$ =" === t? n && i.slice (-n.length) = == n: "~ =" === t? ("" + i + "") .indexOf (n)> - 1: "| =" === t? i === n || i.slice ( 0, n.length + 1) === n + "-":! 1):! 0}}, ENFANT: fonction (e, t, n, r, i) {var o = "nième"! == e slice (0,3),a = "dernier"! == e.slice (-4), s = "de-type" === t; retourne 1 === r && 0 === i? fonction (e) {retour !! e.parentNode }: fonction (t, n, l) {var u, c, p, f, d, h, g = o! == a? "nextSibling": "previousSibling", m = t.parentNode, y = s && t. nodeName.toLowerCase (), v =! l &&! s; if (m) {si (o) {tant que (g) {p = t; tant que (p = p [g]) if (s? nom_noeud.toLowerCase () === y: 1 === p.nodeType) return! 1; h = g = "seulement" === e &&! h && "nextSibling"} return! 0} if (h = [a? m.firstChild : m.lastChild], a && v) {c = m [b] || (m [b] = {}), u = c [e] || [], d = u [0] === T && u [1 ], f = u [0] === T && u [2], p = d && m.childNodes [d]; tandis que (p = ++ d && p && p [p] g | | (f = d = 0) || h.pop ( )) if (1 === p.nodeType && ++ f && p === t) {c [e] = [T, d, f]; pause}} sinon if (v && (u = (t [b] || (t [b] = {})) [e]) && u [0] === T) f = u [1]; sinon tandis que (p = ++ d && p && p [g] || (f = d = 0) || h.pop ()) if (((p? p.nodeName.toLowerCase () === y: 1 === p.nodeType)) && ++ f && (v && ((p [b] || (p [b] = { })) [e] = [T, f]), p === t)) pause; retourne f- = i, f === r || 0 === f% r && f / r> = 0}} }, PSEUDO: fonction (e, t) {var n, r = o.pseudos [e] || o.setFilters [e.toLowerCase ()] || at.error ("pseudo non pris en charge:" + e); return r [b]? r (t): r.longueur> 1? (n = [e, e, "", t], o.filtrefiltres.hasOwnProperty (e.toLowerCase ())? lt (fonction (e, n ) {var i, o = r (e, t), a = longueur, tandis que (a -) i = F.call (e, o [a]), e [i] =! (n [i ] = o [a])}): fonction (e) {retour r (e, 0, n)}): r}}, pseudos: {pas: lt (fonction (e) {var t = [], n = [], r = l (e.replace (z, "$ 1")); retourne r [b]? lt (fonction (e, t, n, i) {var o, a = r (e, null, i, []), s = longueur e; tant que (s -) (o = a [s]) && (e [s] =! (t [s] = o))}): fonction (e, i, o) {retour t [0] = e, r (t, null, o, n),! n.pop ()}}), a: lt (fonction (e) {retour fonction (t) {retour at (e, t) .length> 0}}), contient:lt (fonction (e) {return fonction (t) {return (t.textContent || t.innerText || a (t)). indexOf (e)> - 1}}), lang: lt (fonction (e) {return G.test (e || "") || at.error ("lang non pris en charge:" + e), e = e.replace (rt, it) .toLowerCase (), function (t) {var n; faire si (n = h? t.lang: t.getAttribute ("xml: lang") || t.getAttribute ("lang")) renvoie n = n.toLowerCase (), n === e || 0 = == n.indexOf (e + "-"); tandis que ((t = t.parentNode) && 1 === t.nodeType); return! 1}}), cible: fonction (t) {var n = e.location && e .location.hash; return n && n.slice (1) === t.id}, racine: function (e) {return e === d}, focus: fonction (e) {return e === f.activeElement && (! f.hasFocus || f.hasFocus ()) && !! (type. || e.href || ~ e.tabIndex)}, activé: function (e) {return e.disabled ===! 1 }, désactivé: function (e) {return e.disabled ===! 0}, vérifié: function (e) {var t = e.nodeNom.toLowerCase (); return "entrée "=== t && !! e.checked ||" option "=== t && !! e.selected}, sélectionnée: fonction (e) {retourne e.parentNode && e.parentNode.selectedIndex, e.selected ===! 0}, vide: function (e) {pour (e = e.firstChild; e; e = e.nextossibling) if (e.nodeName> "@" || 3 === e.nodeType || 4 === e.nodeType) return! 1; return! 0}, parent: fonction (e) {return! o.pseudos.empty (e)}, en-tête: fonction (e) {return tt.test (e.nodeName)}, entrée: fonction (e) {return et.test (e.nodeName)}, bouton: fonction (e) {var t = e.nodeNome.toLowerCase (); retourne "entrée" === t && "bouton" === e.type || "bouton" === t}, texte: fonction (e) {var t; retourne "entrée" === e.nodeName.toLowerCase () && "text" === e.type && (null == (t = e.getAttribute ("type")) || t.toLowerCase () === e.type)}, premier: ht (fonction () {return [0]}), dernier: ht (fonction (e, t) {return [t-1]}), eq:ht (fonction (e, t, n) {return [0> n? n + t: n]}), même: ht (fonction (e, t) {var n = 0; pour (; t> n; n + = 2) e.push (n); retour e}), impair: ht (fonction (e, t) {var n = 1; pour (; t> n; n + = 2) e.push (n); retour e}), lt: ht (fonction (e, t, n) {var r = 0> n? n + t: n; pour (; - r> = 0;) e.push (r); retour e }), gt: ht (fonction (e, t, n) {var r = 0> n? n + t: n; pour (; t> ++ r;) e.push (r); renvoyer e}) }}, o.pseudos.nth = o.pseudos.eq; pour (n dans {radio:! 0, case à cocher:! 0, fichier:! 0, mot de passe:! 0, image:! 0}) o.pseudos [ n] = ft (n); pour (n dans {submit:! 0, réinitialiser:! 0}) o.pseudos [n] = dt (n); fonction gt () {} gt.prototype = o.filters = o.pseudos, o.setFilters = new gt; fonction mt (e, t) {var n, r, i, a, s, l, u, c = k [e + ""]; si (c) retourne t? 0: c.slice (0); s = e, l = [], u = o.preFilter; tandis que (s) {(! N || (r = X.exec (s))) && (r && (s = slice (r [0] .length) || s), l.push (i = [])), n =! 1, (r = U.exec (s)) && (n = r.shift (), i.push ({valeur: n, type: r [0] .replace (z, "")}), s = s.slice (n.longueur)); pour (a dans filtre.)! (r = Q [a] .exec (s)) || u [a] &&! (r = u [a] (r)) || (n = r.shift (), i.push ({valeur: n, type: a, correspond à: r}), s = slice (n.length)); if (! n) break} retourne t? s.length : s? at.error (e): k (e, l). Slice (0)} fonction yt (e) {var t = 0, n = e.longueur, r = ""; pour (; n> t ; t ++) r + = e [t] .value; r} fonction vt (e, t, n) {var r = t.dir, o = n && "parentNode" === r, a = C ++; retourne t. première? fonction (t, n, i) {while (t = t [r]) si (1 === t.nodeType || o) retourne e (t, n, i)}: fonction (t, n, s) {var l, u, c, p = T + "" + a; si (s) {tant que (t = t [r]) si ((1 === t.nodeType || o) && e (t, n, s)) retourne! 0} sinon (t = t [r]) si (1 === t.nodeType || o) if (c = t [b] || (t [b] = {} ), (u = c [r]) && u [0] === p) {si ((l = u [1]) ===! 0 || l === i) retourne l ===! 0 } sinon si (u = c [r] = [p], u [1] = e (t, n, s) || i, u [1] ===! 0) renvoie! 0}} fonction bt ( e) {retour e.length> 1? fonction (t, n, r) {var i = e.length; tandis que (i -) si (! e [i] (t, n, r)) renvoie! 1 ; return! 0}:e [0]} fonction xt (e, t, n, r, i) {var o, a = [], s = 0, l = longueur e, u = null! = t; pour (; l> s ; s ++) (o = e [s]) && (! n || n (o, r, i)) && (a.push (o), u && t.push (s)); retourne une} fonction wt (e , t, n, r, i, o) {retourne r &&! r [b] && (r = wt (r)), i &&! i [b] && (i = wt (i, o)), lt (fonction (o, a, s, l) {var u, c, p, f = [], d = [], h = longueur, g = o || Nt (t || "*", s.nodeType ? [s]: s, []), m =! e ||! o && t? g: xt (g, f, e, s, l), y = n? i || (o? e: h || r)? []: a: m; si (n && n (m, y, s, l), r) {u = xt (y, d), r (u, [], s, l), c = u .longueur; tant que (c -) (p = u [c]) && (y [d [c]] =! (m [d [c]] = p))} if (o) {if (i | | e) {si (i) {u = [], c = y.longueur; tandis que (c -) (p = y [c]) && u.push (m [c] = p); i (null, y = [], u, l)} c = y.longueur; tandis que (c -) (p = y [c]) && (u = i? F.call (o, p): f [c]) > -1 && (o [u] =! (A [u] = p))}} sinon y = xt (y === a? Y.splice (h, y.length): y), i? I ( null, a, y, l): M.apply (a, y)})} fonction Tt (e) {var t, n, r, i = e.longueur, a = o.relative [e [0].type], s = a || o.relative [""], l = a? 1: 0, c = vt (fonction (e) {retour e === t}, s,! 0), p = vt (fonction (e) {retourne F.call (t, e)> -1, s,! 0), f = [fonction (e, n, r) {retourne! a && (r || n! == u ) || ((t = n) .nodeType? c (e, n, r): p (e, n, r))}]; pour (; i> l; l ++) if (n = o.relative [ e [l] .type]) f = [vt (bt (f), n)]; sinon {if (n = o.filter [e [l] .type] .apply (null, e [l] .matches ), n [b]) {pour (r = ++ l; i> r; r ++) if (o.relative [e [r]. type]) break; renvoie wt (l> 1 && bt (f), l> 1 && yt (e.slice (0, l-1) .concat ({valeur: "" === e [l-2] .type? "*": ""})). Remplacer (z, "$ 1") , n, r> l && Tt (e.slice (l, r)), i> r && Tt (e = e.slice (r)), i> r && yt (e))} f.push (n)} retourne bt (f )} fonction Ct (e, t) {var n = 0, r = t.longueur> 0, a = e.longueur> 0, s = fonction (s, l, c, p, d) {var h, g , m, y = [], v = 0, b = "0", x = s && [], w = null! = d, C = u, N = s || a && o.find.TAG ("*", ré&& l.parentNode || l), k = T + = null == C? 1: Math.random () || .1; pour (w && (u = l! ​​== f && l, i = n); null! = ( h = N [b]); b ++) {si (a && h) {g = 0; tandis que (m = e [g ++]) si (m (h, l, c)) {p.push (h); pause} w && (T = k, i = ++ n)} r && ((h =! m && h) && v -, s && x.push (h))} if (v + = b, r && b! == v) {g = 0; tandis que (m = t [g ++]) m (x, y, l, c); si (s) {si (v> 0) tandis que (b -) x [b] || y [b] || ( y [b] = q.call (p)); y = xt (y)} M.apply (p, y), w &&! s && y.length> 0 && v + t.length> 1 && at.uniqueSort (p)} retour w && (T = k, u = C), x}; retourne r? Lt (s): s} l = at.compile = fonction (e, t) {varn, r = [], i = [], o = E [e + ""]; si (! O) {t || (t = mt (e)), n = t.longueur; tandis que (n -) o = Tt (t [n]), o [ b]? r.push (o): i.push (o); o = E (e, Ct (i, r))} retour o}; fonction Nt (e, t, n) {var r = 0, i = t.longueur; pour (; i> r; r ++) en (e, t [r], n); retour n} fonction kt (e, t, n, i) {var a, s, u, c , p, f = mt (e); si (! i && 1 === f.longueur) {si (s = f [0] = f [0] .slice (0), s.longueur> 2 && "ID" === (u = s [0]). type && r.getById && 9 === t. nodeType && h && relativale [s [1] .type]) {if (t = (o.find.ID (u.matches [0] .replace (rt, it), t) || []) [0],! t) retourne n; e = e.slice (s.shift (). valeur.longueur)} a = Q.needsContext.test (e)? 0: s.longueur; while (a -) {if (u = s [a], o.relative [c = u.type]) break; if ((p = o.find [c]) && (i = p (u.matches [0] .replace (rt, it), V.test (s [0] .type) && t.parentNode || t))) {if (s.splice (a, 1), e = i.length && yt (s),! E) renvoie M.apply (n , i), n; break}}} retourne l (e, f) (i, t,! h, n, V.test (e)), n} r.sortStable = b.split (""). (A) .join ("") === b, r.detectDuplicates = S, p (), r.sortDetached = ut (fonction (e) {return 1 & e.compareDocumentPosition (f.createElement ("div"))} ), ut (fonction (e) {return e.innerHTML = "<a href='#'> </a>", "# "=== e.firstChild.getAttribute (" href ")}) || ct (" type | href | height | width ", fonction (e, n, r) {return r? t: e.getAttribute (n , "type" === n.toLowerCase ()? 1: 2)}, r.attributes && ut (fonction (e) {return e.innerHTML = "<entrée />", e.firstChild.setAttribute ("valeur" , ""), "" === e.firstChild.getAttribute ("value")}) || ct ("value", fonction (e, n, r) {return r || "input"! == e .nodeName.toLowerCase ()? t: e.defaultValue}), ut (fonction (e) {return null == e.getAttribute ("désactivé")}) || ct (B, fonction (e, n, r) {var i; return r? t: (i = e.getAttributeNode (n)) && i.specified? i.value: e [n] ===! 0? n.toLowerCase (): null}), x.find = at, x.expr = at.selectors, x.expr [":"] = x.expr.pseudos, x.unique = at.uniqueSort, x.text = at.getText, x.isXMLDoc = at.isXML, x.contains = at.contains} (e); var O = {};fonction F (e) {var t = O [e] = {}; retourne x.each (e.match (T) || [], fonction (e, n) {t [n] =! 0}), t} x.Callbacks = fonction (e) {e = "chaîne" == typedee? O [e] || F (e): x.extend ({}, e); varn, r, i, o , a, s, l = [], u =! e.on && [], c = fonction (t) {pour (r = e.mémoire && t, i =! 0, a = s || 0, s = 0, o = l.longueur, n =! 0; l && o> a ++) if (l [a] .apply (t [0], t [1]) ===! 1 && e.stopOnFalse) {r =! 1; pause} n =! 1, l && (u? u.longueur && c (u.shift ()): r? l = []: p.disable ())}, p = {add: function () {if (l) {var t = l.length; (fonction i (t) {x.each (t, fonction (t, n) {var r = x.type (n); "fonction" === r? e.unique && p. has (n) || l.push (n): n && n.length && "chaîne"! == r && i (n)}) (arguments), n? o = l.length: r && (s = t, c ( r))} retourne cette}, supprime: function () {return l && x.each (arguments, fonction (e, t) {var r; while ((r = x.inArray (t, l, r)))> - 1 ) l.splice (r, 1), n ​​&& (o>= r && o -, a> = r && a -)}, this}, a: function (e) {return e? x.inArray (e, l)> - 1:! (! l ||! l.length )}, vide: fonction () {retour l = [], o = 0, ceci}, désactiver: fonction () {retour l = u = r = t, ceci}, désactivé: fonction () {retour! l} , lock: function () {return u = t, r || p.disable (), this}, locked: function () {return! u}, fireWith: function (e, t) {return! l || i && ! u || (t = t || [], t = [e, t.slice? t.slice (): t], n? u.push (t): c (t)), cela}, feu : function () {return p.fireWith (this, arguments), this}, tiré: function () {return !! i}}; return p}, x.extend ({Différé: function (e) {var t = [["résoudre", "terminé", x.Callbacks ("une fois en mémoire"), "résolu"], ["rejeter", "échouer", x.Callbacks ("une fois en mémoire"), "rejeté"], [ "notify", "progress", x.Callbacks ("memory")]], n = "en attente", r = {state: function () {return n},toujours: function () {return i.done (arguments) .fail (arguments), this}, alors: function () {var e = arguments; renvoie x.Deferred (fonction (n) {x.each (t, fonction (t, o) {var a = o [0], s = x.isFunction (e [t]) && e [t]; i [o [1]] (fonction () {var e = s && s.apply (this , arguments); e && x.isFunction (e.promise)? e.promise (). done (n.resolve) .fail (n.reject) .progress (n.notify): n [a + "Avec"] (this = == r? n.promise (): this, s? [e]: arguments)})}, e = null}). promise ()}, promesse: fonction (e) {retour null! = e? x .extend (e, r): r}}, i = {}; retour r.pipe = r.then, x.each (t, fonction (e, o) {var a = o [2], s = o [3]; r [o [1]] = a.add, s && a.add (fonction () {n = s}, t [1 ^ e] [2] .disable, t [2] [2] .lock ), i [o [0]] = fonction () {retourne i [o [0] + "avec"] (this === i? r: this, arguments), this}, i [o [0] + "Avec"] = a.fireWith}), r.promise (i), e && e.call (i, i), i}, lorsque: fonction (e) {var t = 0, n = g.call (arguments) , r = longueur n,i = 1! == r || e && x.isFunction (e.promise)? r: 0, o = 1 === i? e: x.Deferred (), a = function (e, t, n) {return fonction (r) {t [e] = ceci, n [e] = arguments.longueur> 1? g.call (arguments): r, n === s? o.notifyWith (t, n): - i || o.resolveWith (t, n)}}, s, l, u; if (r> 1) pour (s = tableau (r), l = tableau (r), u = tableau (r); r> t; t ++) n [t] && x.isFunction (n [t] .promise)? n [t] .promise (). done (a (t, u, n)). fail (o.reject) .progress ( a (t, l, s)): - i; retourne i || o.resolveWith (u, n), o.promise ()}}), x.support = fonction (t) {var n, r, o, s, l, u, c, p, f, d = a.createElement ("div"); if (d.setAttribute ("nom de classe", "t"), d.innerHTML = "<lien /> < table> </ table> <a href='/a'> a </a> <input type = 'checkbox' /> ", n = d.getElementsByTagName (" * ") || [], r = d. getElementsByTagName ("a") [0],! r ||! r.style ||! n.length) renvoie t; s = a.createElement ("sélectionnez "), u = s.appendChild (a.createElement (" option ")), o = d.getElementsByTagName (" input ") [0], r.style.cssText =" top: 1px; float: left; opacity : .5 ", t.getSetAttribute =" t "! == d.className, t.leadingWhitespace = 3 === d.firstChild.nodeType, t.tbody =! D.getElementsByTagName (" tbody "). Length, t .htmlSerialize = !! d.getElementsByTagName ("link"). length, t.style = / top / .test (r.getAttribute ("style")), t.hrefNormalized = "/ a" === r.getAttribute ("href"), t.opacity = / ^ 0.5 / .test (style.opacité), t.cssFloat = !! r.style.cssFloat, t.checkOn = !! o.value, t.optSelected = u.selected, t.enctype = !! a.createElement ("form"). enctype, t.html5Clone = "<: nav> </: nav>"! == a.createElement ("nav"). cloneNode ( ! 0) .outerHTML, t.inlineBlockNeedsLayout =! 1, t.shrinkWrapBlocks =! 1, t.pixelPosition =! 1, t.deleteExpando =! 0, t.noCloneEvent =! 0, t.reliableMarginRight =! 0, t.boxSizingReliable =! 0, o.checked =! 0, t.noCloneChecked = o.cloneNode (! 0) .checked, s.disabled =! 0, t.optDisabled =! U.disabled; essayez {delete d.test} catch (h) {t.deleteExpando =! 1} o = a.createElement ("entrée"), o.setAttribute ("valeur" , ""), t.input = "" === o.getAttribute ("valeur"), o.value = "t", o.setAttribute ("type", "radio"), t.radioValue = "t "=== o.value, o.setAttribute (" coché "," t "), o.setAttribute (" nom "," t "), l = a.createDocumentFragment (), l.appendChild (o), t .appendChecked = o.checked, t.checkClone = l.cloneNode (! 0) .cloneNode (! 0) .lastChild.checked, d.attachEvent && (d.attachEvent ("onclick", fonction () {t.noCloneEvent =! 1}), d.cloneNode (! 0) .click ()); pour (f dans {submit:! 0, changer:! 0, focusin:!0}) d.setAttribute (c = "sur" + f, "t"), t [f + "bulles"] = c dans e || d.attributes [c] .expando ===! 1; d.style .backgroundClip = "content-box", d.cloneNode (! 0) .style.backgroundClip = "", t.clearCloneStyle = "content-box" === d.style.backgroundClip; pour (f dans x (t) ) pause; retour t.ownLast = "0"! == f, x (fonction () {var n, r, o, s = "remplissage: 0; marge: 0; bordure: 0; affichage: bloc; boîte- dimensionnement: content-box; -moz-box-dimensionnement: content-box; -webkit-box-dimensionnement: content-box; ", l = a.getElementsByTagName (" body ") [0]; l && (n = a. createElement ("div"), n.style.cssText = "border: 0; width: 0; height: 0; position: absolute; top: 0; left: -9999px; margin-top: 1px", l.appendChild ( n) .appendChild (d), d.innerHTML = "<table> <tr> <td> </ td> <td> t </ td> </ tr> </ table>", o = d.getElementsByTagName ("td"), o [0] .style.cssText = "padding: 0; marge: 0; bordure: 0; affichage: aucun", p = 0 === o [0] .offsetHeight, o [0 ] .style.display = "", o [1] .style.display = "aucun", t.reliableHiddenOffsets = p && 0 === o [0] .offsetHeight, d.innerHTML = "", d.style.cssText = "boîte-dimensionnement: border-box; -moz-box-dimensionnement: border-box; -webkit-box-dimensionnement: border-box; remplissage: 1px; border: 1px; affichage: bloc; largeur: 4px; margin-top : 1%; position: absolue; haut: 1%; ", x.swap (l, null! = L.style.zoom? {Zoom: 1}: {}, fonction () {t.boxSizing = 4 == = d.offsetWidth}), e.getComputedStyle && (t.pixelPosition = "1%"! == (e.getComputedStyle (d, null) || {}). top, t.boxSizingReliable = "4px" === ( e.getComputedStyle (d, null) || {width: "4px"}). width, r = d.appendChild (a.createElement ("div")), r.style.cssText = d.style.cssText = s , style.marginRight = r.style.width = "0", d.style.width = "1px", t.reliableMarginRight =! parseFloat ((e.getComputedStyle (r, null) || {}). marginRight), typeof d .style.zoom! == i && (d.innerHTML = "", d.style.cssText = s + "width: 1px; padding: 1px; display: inline; zoom: 1", t.inlineBlockNeedsLayout = 3 === d .offsetWidth, d.style.display = "block", d.innerHTML = "<div> </ div>", d.firstChild.width = "5px", t.shrinkWrapBlocks = 3! == d.offsetWidth , t.inlineBlockNeedsLayout && (l.style.zoom = 1)), l.removeChild (n), n = d = o = r = null)}), n = s = l = u = r = o = null, t1 ", t.inlineBlockNeedsLayout = 3 === d.offsetWidth, d.style.display =" block ", d.innerHTML =" <div> </ div> ", d.firstChild.style.width =" 5px " , t.shrinkWrapBlocks = 3! == d.offsetWidth, t.inlineBlockNeedsLayout && (l.style.zoom = 1)), l.removeChild (n), n = d = o = r = null)}), n = s = l = u = r = o = nul, t1 ", t.inlineBlockNeedsLayout = 3 === d.offsetWidth, d.style.display =" block ", d.innerHTML =" <div> </ div> ", d.firstChild.style.width =" 5px " , t.shrinkWrapBlocks = 3! == d.offsetWidth, t.inlineBlockNeedsLayout && (l.style.zoom = 1)), l.removeChild (n), n = d = o = r = null)}), n = s = l = u = r = o = nul, t
} ({}); var B = / (?: \ {[\ s \ s] * \} | \ [[\ s \ s] * \]) $ /, P = / ([AZ]) / g ; fonction R (e, n, r, i) {if (x.acceptData (e)) {varo, a, s = x.expando, l = e.nodeType, u = l? x.cache: e, c = l? e [s]: e [s] && s; if (c && u [c] && (i || u [c] .data) || r! == t || "string"! = typeof n) retourne c || (c = l? e [s] = p.pop () || x.guid ++: s), u [c] || (u [c] = l? {}: {toJSON: x. noop}), ("objet" == typeof n || "fonction" == typeof n) && (i? u [c] = x.extend (u [c], n): u [c] .data = x.extend (u [c] .data, n)), a = u [c], i || (a.data || (a.data = {}), a = a.data), r! = = t && (a [x.camelCase (n)] = r), "chaîne" == typeof n? (o = a [n], null == o && (o = a [x.camelCase (n)])) : o = a, o}} fonction W (e, t, n) {if (x.acceptData (e)) {var, i, o = e.nodeType, a = o? x.cache: e, s = o? e [x.expando]: x.expando; if (a [s]) {if (t && (r = n? a [s]: a [s] .data)) {x.isArray (t) ? t = t.concat (x.map (t, x.camelCase)): t dans r? t = [t] :( t = x.camelCase (t), t = t dans r? [t]: t .split ("")), i = t.length; tandis que (i -) supprime r [t [i]]; if (n?! I (r):! x.isEmptyObject (r)) return} (n || (supprimer un [s] .data, I (un [s]))) && (o? x.cleanData ([e] ,! 0): x.support.deleteExpando || a! = a.window? supprimer un [s]: un [s] = null)}}} x.extend ({cache: {}, noData: {applet:! 0, embed:! 0, object: "clsid: D27CDB6E-AE6D-11cf- 96B8-444553540000 "}, hasData: fonction (e) {retour e = e.nodeType? X.cache [e [x.expando]]: e [x.expando], !! e &&! I (e)}, données : fonction (e, t, n) {retour R (e, t, n)}, removeData: fonction (e, t) {retour W (e, t)}, _ donnée: fonction (e, t, n) { retourne R (e, t, n,! 0)}, _ removeData: fonction (e, t) {retour W (e, t,! 0)}, acceptData: fonction (e) {if (e.nodeType && 1! == e.nodeType && 9! == e.nodeType) return! 1; var t = e.nodeName && x.noData [e.nodeName.toLowerCase ()]; return! t || t! ==! 0 && e.getAttribute ("classid") === t}}), x.fn.extend ({data: function (e, n) {var r, i,o = null, a = 0, s = this [0]; si (e === t) {if (this.length && (o = x.data (s), 1 === s.nodeType &&! x._data (s, "parsedAttrs"))) {pour (r = s.attributes; r.length> a; a ++) i = r [a] .name, 0 === i.indexOf ("data -") && ( i = x.camelCase (i.slice (5)), $ (s, i, o [i])); x._data (s, "parsedAttrs",! 0)} return o} return "object" == typeof e? this.each (fonction () {x.data (this, e)}): arguments.length> 1? this.each (function () {x.data (this, e, n)}): s ? $ (s, e, x.data (s, e)): null}, removeData: fonction (e) {retour this.each (fonction () {x.removeData (this, e)})}}); fonction $ (e, n, r) {si (r === t && 1 === e.nodeType) {var i = "données -" + n.remplace (P, "- $ 1"). toLowerCase (); if (r = e.getAttribute (i), "string" == typeof r) {try {r = "true" === r?! 0: "false" === r?! 1: "null" == = r? null: + r + "" === r? + r: B.test (r)? x.parseJSON (r):r} catch (o) {} x.data (e, n, r)} sinon r = t} renvoyer r} fonction I (e) {var t; pour (t dans e) if (("data"! = = t ||! x.isEmptyObject (e [t])) && "toJSON"! == t) retourne! 1; retourne! 0} x.extend ({file d'attente: fonction (e, n, r) {var i ; retourne e? (n = (n || "fx") + "file d'attente", i = x._data (e, n), r && (! i || x.isArray (r)? i = x._data ( e, n, x.makeArray (r)): i.push (r)), i || []): t}, file d'attente: fonction (e, t) {t = t || "fx"; var n = x.queue (e, t), r = longueur.n, i = n.shift (), o = x._queueHooks (e, t), a = fonction () {x.dequeue (e, t)} ; "inprogress" === i && (i = n.shift (), r -), i && ("fx" === t && n.unshift ("inprogress"), supprimez o.stop, i.call (e, a, o)),! r && o && o.empty.fire ()}, _ queueHooks: fonction (e, t) {var n = t + "queueHooks"; renvoyer x._data (e, n) || x._data (e, n, {vide: x.Callbacks ("une fois en mémoire"). add (function () {x._removeData (e,t + "file d'attente"), x._removeData (e, n)})}}}), x.fn.extend ({file d'attente: fonction (e, n) {var r = 2; retourne "chaîne"! = type e && (n = e, e = "fx", r -), r> arguments.length? x.queue (this [0], e): n === t? this: this.each (fonction () {var t = x.queue (this, e, n); x._queueHooks (this, e), "fx" === e && "inprogress"! == t [0] && x.dequeue (this, e)} )}, suppression de la file d'attente: fonction (e) {retourne this.each (fonction () {x.dequeue (this, e)})}, délai: fonction (e, t) {retourne e = x.fx? x.fx .speeds [e] || e: e, t = t || "fx", this.queue (t, fonction (t, n) {var r = setTimeout (t, e); n.stop = fonction () {clearTimeout (r)}})}, clearQueue: fonction (e) {retourne this.queue (e || "fx", [])}, promesse: fonction (e, n) {var, i = 1, o = x.Deferred (), a = ceci, s = ceci.longueur, l = fonction () {- i || o.resolveWith (a, [a])}; "chaîne"! = typede e && (n = e, e = t), e = e || "fx", tandis que (s -) r = x._data (a [s], e + "queueHooks"), r && r.empty && (i ++, r.empty.add (l)); renvoyer l (), o.promise (n)}}); var z, X, U = / [\ t \ r \ n \ f] / g, V = / \ r / g, Y = / ^ (?: entrée | sélectionner | textarea | bouton | objet) $ / i, J = / ^ (? : a | area) $ / i, G = / ^ (?: coché | sélectionné) $ / i, Q = x.support.getSetAttribute, K = x.support.input; x.fn.extend ({attr: function (e, t) {return x.access (this, x.attr, e, t, arguments.length> 1)}, removeAttr: function (e) {retourne this.each (function () {x.removeAttr (this , e)})}, prop: fonction (e, t) {retourne x.access (this, x.prop, e, t, arguments.length> 1)}, removeProp: fonction (e) {retourne e = x .propFix [e] || e, this.each (function () {try {this [e] = t, supprimez ceci [e]} catch (n) {}})}, addClass: function (e) {var t, n, r, i, o, a = 0, s = ceci.longueur, l = "chaîne" == typede e && e; if (x.isFunction (e)) renvoie this.each (fonction (t) {x (this) .addClass (e.call (this, t, this.className))}); if (l) pour (t = (e || "").match (T) || []; s> a; a ++) if (n = ceci [a], r = 1 === n.nodeType && (n.NomClasse? ("" + n.NomClasse + ""). (U, ""): "")) {o = 0; tandis que (i = t [o ++]) 0> r.indexOf ("" + i + "") && (r + = i + ""); n.className = x.trim (r)} retourne ceci}, removeClass: fonction (e) {var t, n, r, i, o, a = 0, s = ceci.longueur, l = 0 === arguments.length | | "string" == typeof e && e; if (x.isFunction (e)) renvoie this.each (fonction (t) {x (this) .removeClass (e.call (this, t, this.className))}} ; si (l) pour (t = (e || ""). match (T) || []; s> a; a ++) si (n = ce [a], r = 1 === n.nodeType && (n.className? ("" + n.className + "") .replace (U, ""): "")) {o = 0; tant que (i = t [o ++]) tant que (r.indexOf ("" " + i + "")> = 0) r = r.remplace ("" + i + "", ""); n.className = e? x.trim (r): ""} return this}, toggleClass: fonction (e, t) {var n = typede e; retourne" booléen "== typede t &&" chaîne "=== n? t? this.addClass (e): this.removeClass ( e): x.isFunction (e)? this.each (fonction (n) {x (this) .toggleClass (e.call (this, n, this.className, t), t)}): this.each ( function () {if ("string" === n) {var t, r = 0, o = x (ceci), a = e.match (T) || []; tandis que (t = a [r ++] ) o.hasClass (t)? o.removeClass (t): o.addClass (t)} else (n === i || "boolean" === n) && (this.className && x._data (this, " __className __ ", this.ClassName), this.ClassName = this.ClassName || e ===! 1?" ": x._data (this," __ className __ ") ||" ")}), hasClass: function ( e) {var t = "" + e + "", n = 0, r = this.length; pour (; r> n; n ++) si (1 === this [n] .nodeType && ("" + this [ n] .className + "") .replace (U, "") .indexOf (t)>= 0) return! 0; return! 1}, val: function (e) {var n, r, i, o = this [0]; {if (arguments.length) renvoie i = x.isFunction (e), this.each (function (n) {var o; 1 === this.nodeType && (o = i? e.call (this, n, x (this) .val ()): e, null == o? o = "": "numéro" == typeof o? o + = "": x.isArray (o) && (o = x.map (o, fonction (e) {retour null == e? "": e + "" })), r = x.valHooks [this.type] || x.valHooks [this.nodeName.toLowerCase ()], r && "set" dans r && r.set (this, o, "valeur")! == t || (this.value = o))}); if (o) renvoie r = x.valHooks [type.o] || x.valHooks [o.nodeName.toLowerCase ()], r && "get" dans r && ( n = r.get (o, "valeur"))!! == t? n: (n = o.valeur, "chaîne" == type de n? n.remplacer (V, ""): null == n? "": n)}}}), x.extend ({valHooks: {option: {get: function (e)} {var t = x.find.attr (e, "valeur"); retourne null! = t? t: e.text}}, sélectionnez: {get: function (e) {var t, n, r = e.options, i = e.selectedIndex, o = "select-one" === e.type || 0> i, a = o? null: [], s = o? i + 1: longueur, l = 0> i? s: o? i: 0; pour (; s> l; l ++) si (n = r [ l],! (! n.selected && l! == i || (x.support.optDisabled? n.disabled: null! == n.getAttribute ("disabled")) || n.parentNode.disabled && x.nodenom (n .parentNode, "optgroup"))) {if (t = x (n) .val (), o) renvoie t; a.push (t)} renvoie a}, définit: fonction (e, t) {var n , r, i = e.options, o = x.makeArray (t), a = i.longueur; tandis que (a -) r = i [a], (r.selected = x.inArray (x (r) .val (), o)> = 0) && (n =! 0); retourne n || (e.selectedIndex = -1), o}}}, attr: fonction (e, n, r) {var o , a, s = e.nodeType; if (e && 3! == s && 8! == s && 2! == s) renvoie le typede e.getAttribute === i? x.prop (e, n, r) :( 1 == = s && x.isXMLDoc (e) || (n = n.toLowerCase (), o = x.attrHooks [n] || (x.expr.match.bool.test (n)? X: z)), r = == t? o && "get "in o && null! == (a = o.get (e, n))? a: (a = x.find.attr (e, n), null == a? t: a): null! == r? o && "set" dans o && (a = o.set (e, r, n))! == t? a: (e.setAttribute (n, r + ""), r) :( x.removeAttr (e , n), t))}, removeAttr: fonction (e, t) {var n, r, i = 0, o = t && t.match (T); if (o && 1 === e.nodeType) tandis que (n = o [i ++]) r = x.propFix [n] || n, x.expr.match.bool.test (n)? K && Q ||! G.test (n)? e [r] =! 1: e [x.camelCase ("default -" + n)] = e [r] =! 1: x.attr (e, n, ""), e.removeAttribute (Q? n: r)}, attrHooks: {type : {set: function (e, t) {if (! x.support.radioValue && "radio" === t && x.nodeName (e, "input")) {var n = e.value; renvoyer e.setAttribute (" type ", t), n && (e.value = n), t}}}}, propFix: {" pour ":" htmlFor "," class ":" className "}, prop: fonction (e, n, r ) {var i, o, a, s = e.nodeType; if (e && 3!== s && 8! == s && 2! == s) renvoie a = 1! == s ||! x.isXMLDoc (e), a && (n = x.propFix [n] || n, o = x.propHooks [ n]), r! == t? o && "set" dans o && (i = o.set (e, r, n))! == t? i: e [n] = r: o && "get" dans o && null ! == (i = o.get (e, n))? i: e [n]}, propHooks: {tabIndex: {get: function (e) {var t = x.find.attr (e, "tabindex "); return t? parseInt (t, 10): Y.test (e.nodeName) || J.test (e.nodeName) && e.href? 0: -1}}}}), X = {set: fonction (e, t, n) {retourne t ===! 1? x.removeAttr (e, n): K && Q ||! G.test (n)? e.setAttribute (! Q && x.propFix [n] || n, n): e [x.camelCase ("défaut -" + n)] = e [n] =! 0, n}}, x.each (x.expr.match.bool.source.match (/ \ w + / g), fonction (e, n) {var r = x.expr.attrHandle [n] || x.find.attr; x.expr.attrHandle [n] = K && Q ||! G.test (n) ? fonction (e, n, i) {var o = x.expr.attrHandle [n], a = i? t: (x.expr.attrHandle [n] = t)! = r (e, n, i) ? n.toLowerCase (): null;return x.expr.attrHandle [n] = o, a}: function (e, n, r) {return r? t: e [x.camelCase ("default -" + n)]? n.toLowerCase (): null}}, K && Q || (x.attrHooks.value = {set: function (e, n, r) {return x.nodeName (e, "input")? (e.defaultValue = n, t): z && z .set (e, n, r)}}), Q || (z = {ensemble: fonction (e, n, r) {var i = e.getAttributeNode (r); retourne i || e.setAttributeNode (i = e.ownerDocument.createAttribute (r)), i.value = n + = "", "valeur" === r || n === e.getAttribute (r)? n: t}}, x.expr. attrHandle.id = x.expr.attrHandle.name = x.expr.attrHandle.coords = fonction (e, n, r) {var i; renvoyer r? t: (i = e.getAttributeNode (n)) && "" ! == i.value? i.value: null}, x.valHooks.button = {obtenir: fonction (e, n) {var r = e.getAttributeNode (n); renvoyer r && r.specified? r.value: t }, définir: z.set}, x.attrHooks.contenteditable = {ensemble: fonction (e, t, n) {z.set (e, "" === t?! 1: t, n)}}, x.each (["width "," height "], function (e, n) {x.attrHooks [n] = {set: function (e, r) {return" "=== r? (e.setAttribute (n," auto " ), r): t}}})), x.support.hrefNormalized || x.each (["href", "src"], fonction (e, t) {x.propHooks [t] = {get: fonction (e) {return e.getAttribute (t, 4)}}}), x.support.style || (x.attrHooks.style = {get: fonction (e) {return e.style.cssText || t }, set: function (e, t) {return e.style.cssText = t + ""}}), x.support.optSelected || (x.propHooks.selected = {get: function (e) {var t = e.parentNode; return t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex), null}}), x.each (["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPacing", " "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {x.propFix [this.toLowerCase ()] = this}), x.support.enctype || (x.propFix.enctype = "encoding"), x.each (["radio", "case à cocher"], fonction () { x.valHooks [this] = {set: function (e, n) {return x.isArray (n)? e.checked = x.inArray (x (e) .val (), n)> = 0: t} }, x.support.checkOn || (x.valHooks [this] .get = fonction (e) {retour null === e.getAttribute ("valeur")? "sur": e.value})}); var Z = / ^ (?: entrée | sélectionner | textarea) $ / i, et = / ^ clé /, tt = / ^ (?: souris | menu contextuel) | clic /, nt = / ^ (?: focusinfocus | focusoutblur ) $ /, rt = / ^ ([^.] *) (?: \. (. +) |) $ /; function it () {return! 0} function ot () {return! 1} fonction at ( ) {try {return a.activeElement} catch (e) {}} x.event = {global: {}, ajoutez: fonction (e, n, r, o, a) {var s, l, u, c, p, f, d, h, g, m, y, v = x._data (e); si (v) {r.handler && (c = r, r = c.handler, a = c.selector), r .guid || (r.guid = x.guid ++), (l = v.events) || (l = v.events = {}), (f = v.handle) || (f = v.descripteur = fonction (e) {type de retour x === i || e && x.event.triggered === e.type? t: x.event.dispatch.apply (f.elem, arguments)}, f.elem = e), n = (n || ""). match (T) || [""], u = longueur n; tandis que (u -) s = rt.exec (n [u]) || [ ], g = y = s [1], m = (s [2] || ""). scission ("."). sort (), g && (p = x.event.special [g] || { }, g = (a? p.delegateType: p.bindType) || g, p = x.event.special [g] || {}, d = x.extend ({type: g, origType: y, données : o, gestionnaire: r, guid: r.guid, sélecteur: a, needsContext: a && x.expr.match.needsContext.test (a), espace de noms: m.join (".")}, c), (h = l [g]) || (h = l [g] = [], h.delegateCount = 0, p.setup && p.setup.call (e, o, m, f)! ==! 1 || (e. addEventListener? e.addEventListener (g, f,! 1): e.attachEvent && e.attachEvent ("on" + g, f))), p.add && (p.add.call (e, d), d.handler. guid || (d.handler.guid = r.guid)), a? h.splice (h.delegateCount ++, 0, d): h.push (d), x.event.global [g] =! 0); e = null}}, remove: fonction (e, t, n, r, i) {var o, a, s, l, u, c, p, f, d, h , g, m = x.hasData (e) && x._data (e); if (m && (c = m.events)) {t = (t || ""). match (T) || [""] , u = t.length; tandis que (u -) if (s = rt.exec (t [u]) || [], d = g = s [1], h = (s [2] || " ") .split (". "). sort (), d) {p = événement.spécial [d] || {}, d = (r? p.delegateType: p.bindType) || d, f = c [d] || [], s = s [2] & RegExp ("(^ | \\.)" + h.join ("\\. (?:. * \\. |)") + " (\\. | $) "), l = o = f.length; tandis que (o -) a = f [o],! i && g! == a.origType || n && n.guid! == a.guid || s &&! s.test (a.namespace) || r && r! == a.selector && ("**"! == r ||! a.selector) || (f.splice (o, 1), a .selector && f.delegateCount -, p.remove && p.remove.call (e, a)); l &&! f.length && (p.teardown && p.teardown.call (e, h, m.handle)!! ==! 1 || x.removeEvent (e, d, m.handle),supprimer c [d])} else pour (d dans c) x.event.remove (e, d + t [u], n, r,! 0); x.isEmptyObject (c) && (supprimer m.handle, x._removeData (e, "événements"))}}, déclencheur: fonction (n, r, i, o) {var s, l, u, c, p, f, d, h = [i || a] , g = v.call (n, "type")? n.type: n, m = v.call (n, "espace de nom")? n.namespace.split ("."): []; if (u = f = i = i || a, 3! == i.nodeType && 8! == i.nodeType &&! nt.test (g + x.event.triggered) && (g.indexOf (".")> = 0 && ( m = g.split ("."), g = m.shift (), m.sort ()), l = 0> g.indexOf (":") && "sur" + g, n = n [x .expando]? n: new x.Event (g, "objet" == typede n && n), n.isTrigger = o? 2: 3, n.namespace = m.join ("."), n.namespace_re = n .namespace? RegExp ("(^ | \\.)" + m.join ("\\. (?:. * \\. |)") + "(\\. | $)"): null, n .result = t, n.target || (n.target = i), r = null == r? [n]: x.makeArray (r, [n]),p = x.event.special [g] || {}, o ||! p.trigger || p.trigger.apply (i, r)! ==! 1)) {if (! o &&! p.noBubble && ! x.isWindow (i)) {pour (c = p.delegateType || g, nt.test (c + g) || (u = u.parentNode); u; u = u.parentNode) h.push ( u), f = u; f === (i.ownerDocument || a) && h.push (f.defaultView || f.parentWindow || e)} d = 0; while ((u = h [d ++]) &&! n.isPropagationStopped ()) n.type = d> 1? c: p.bindType || g, s = (x._data (u, "events") || {}) [n.type] && x. _data (u, "handle"), s && s.apply (u, r), s = l && u [l], s && x.acceptData (u) && s.apply && s.apply (u, r) ===! 1 && n.preventDefault () ; if (n.type = g,! o &&! n.isDefaultPrevented () && (! p._default || p._default.apply (h.pop (), r) ===! 1) && x.acceptData (i ) && l && i [g] &&! x.isWindow (i)) {f = i [l], f && (i [l] = null), x.event.triggered = g; essayer {i [g] ()} catch (y) {} x.event.triggered = t, f && (i [l] = f)} retourne n.result}}, dispatch: fonction (e) {e = x.event.fix (e); varn, r, i, o, a, s = [], l = g.call (arguments), u = (x._data (this, "events") || {}) [type.e] || [], c = x.event.special [ e.type] || {}; if (l [0] = e, e.delegateTarget = this,! c.preDispatch || c.preDispatch.call (this, e)! ==! 1) {s = x .event.handlers.call (this, e, u), n = 0; tandis que ((o = s [n ++]) &&! e.isPropagationStopped ()) {e.currentTarget = o.elem, a = 0; while (((i = o.handlers [a ++]) &&! e.isImmediatePropagationStopped ()) (! e.namespace_re || e.namespace_re.test (i.namespace)) && (e.handleObj = i, e.data = i .data, r = ((x.event.special [i.origType] || {}). handle || i.handler) .apply (o.elem, l), r! == t && (e.result = r) ===! 1 && (e.preventDefault (), e.stopPropagation ()))} return c.postDispatch && c.postDispatch.call (this, e), e.result}}, gestionnaires: fonction (e, n) {var r, i, o, a, s = [], l = n.delegateCount, u = e.target; if (l && u.nodeType && (! e.button || "cliquez"! == e.type)) pour (; u! = this; u = u.parentNode || this) if (1 === u. nodeType && (u.disabled! ==! 0 || "clic"! == e.type)) {pour (o = [], a = 0; l> a; ++) i = n [a], r = i.selector + "", o [r] === t && (o [r] = i.needsContext? x (r, this) .index (u)> = 0: x.find (r, this, null, [ u)) longueur), o [r] && o.push (i); o.length && s.push ({elem: u, gestionnaires: o})} retourne n.length> l && s.push ({elem: this, gestionnaires : n.slice (l)}), s}, correction: fonction (e) {if (e [x.expando]) renvoie e; var t, n, r, i = type e, o = e, s = this.fixHooks [i]; s || (this.fixHooks [i] = s = tt.test (i)? this.mouseHooks: et.test (i)? ceci.keyHooks: {}), r = s .props? this.props.concat (s.props): this.props, e = new x.Evénement (o), t = r.longueur; tandis que (t -) n = r [t], e [n ] = o [n]; retourne e.target || (e.target = o.srcElement || a), 3 === e.target.nodeType && (e.target = e.target.parentNode), e.metaKey = !! e.metaKey, s.filter? s.filter (e, o): e}, props: "altKey bulles annulable ctrlKey currentTarget eventPhase metaKey related. KeyKey timeStamp view qui" .split (""), fixHooks: {}, keyHooks: {props: "char charCode key keyCode" .split (""), filtre: fonction (e, t) {retour null == e.which && (e.which = null! = t.charCode? t .charCode: t.keyCode), e}}, mouseHooks: {props: "bouton boutons clientX clientY deElement offsetX pageY pageY pageX écranY écranY écranElement" .split (""), filtre: fonction (e, n) {var r, i, o, s = n.button, l = n.fromElement; return null == e.pageX && null! = n.clientX && (i = e.target.ownerDocument || a, o = i.documentElement, r = i. body, e.pageX = n.clientX + (o && o.scrollLeft || r && r.scrollLeft || 0) - (o && o.clientLeft || r && r.clientLeft || 0), e.pageY = n.clientY + (o && o.scrollTop || r && r.scrollTop || 0) - (o && o.clientTop || r && r.clientTop || 0)) !! e.relatedTarget && l && (e.relatedTarget = l === e.target?n.toEto.html : l), e.which || s === t || (e.which = 1 & s? 1: 2 & s? 3: 4 & s? 2: 0), e}}, spécial: {load: {noBubble:! 0 }, focus: {trigger: function () {if (this! == at () && this.focus) try {retour this.focus (),! 1} catch (e) {}}, delegateType: "focusin"} , flou: {trigger: function () {retournez this === at () && this.blur? (this.blur (),! 1): t}, delegateType: "focusout"}, cliquez sur: {trigger: function ( ) {return x.nodeName (this, "input") && "case à cocher" === this.type && this.click? (this.click (),! 1): t}, _ défaut: function (e) {return x. nodeName (e.target, "a")}}, beforeunload: {postDispatch: function (e) {e.result! == t && (e.originalEvent.returnValue = e.result)}}},simuler: fonction (e, t, n, r) {var i = x.extend (new x.Event, n, {type: e, isSimulated:! 0, originalEvent: {}}); r? x.event. déclencheur (i, null, t): x.event.dispatch.call (t, i), i.isDefaultPrevented () && n.preventDefault ()}}, x.removeEvent = a.removeEventListener? function (e, t, n ) {e.removeEventListener && e.removeEventListener (t, n,! 1)}: fonction (e, t, n) {var r = "sur" + t; e.detachEvent && (typede e [r] === i && (e [r] = null), e.detachEvent (r, n))}, x.Event = fonction (e, n) {retourne cette instance de x.Event? (e && e.type? (this.originalEvent = e, this. type = e.type, this.isDefaultPrevented = e.defaultPrevented || e.returnValue ===! 1 || e.getPreventDefault && e.getPreventDefault ()? it: ot): this.type = e, n && x.extend (this, n), this.timeStamp = e && e.timeStamp || x.now (), this [x.expando] =! 0, t): new x.Event (e, n)}, x.Event.prototype = {isDefaultPrevented : ot,isPropagationStopped: ot, isImmediatePropagationStopped: ot, preventDefault: function () {var e = this.originalEvent; this.isDefaultPrevented = elle, e && (e.preventDefault? e.preventDefault (): e.returnValue =! 1)}, arrêter & function () {var e = this.originalEvent; this.isPropagationStopped = it, e && (e.StopPropagation && e.stopPropagation (), e.cancelBubble =! 0)}, stopImmediatePropagation: function () {this.isImmediatePropagationStopped, cela. stopPropagation ()}}, x.each ({mouseenter: "mouseover", mouseleave: "mouseout"}, fonction (e, t) {x.event.special [e] = {delegateType: t, bindType: t, handle : fonction (e) {var n, r = ceci, i = e.relatedTarget, o = e.handleObj; return (! i || i! == r &&! x.contains (r, i)) && (e. type = o.origType, n = o.handler.apply (this, arguments), e.type = t), n}}}), x.support.submitBubbles || (x.event.special.submit = {setup : function () {retourne x.nodeName (this, "form")?! 1: (x.event.add (this, "click._submit keypress._submit", fonction (e) {var n = e.target, r = x.nodeName (n, "input") || x.nodeName (n, "bouton")? n.form: t; r &&! x._data (r, "submitBubbles") && (x.event.add (r, "submit._submit" , fonction (e) {e._submit_bubble =! 0}), x._data (r, "submitBubbles",! 0))}), t)}, postDispatch: fonction (e) {e._submit_bubble && (delete e. _submit_bubble, this.parentNode &&! e.isTrigger && x.event.simulate ("submit", this.parentNode, e,! 0))}, démontage: function () {return x.nodeName (this, "form")?! 1 : ((x.event.remove (this, "._ submit"), t)}}), x.support.changeBubbles || (x.event.special.change = {setup: function () {return Z.test ( this.nodeName)? (("case à cocher" === this.type || "radio" === this.type) && (x.event.add (this, "propertychange._change", fonction (e) {"vérifié" === e.originalEvent.propertyName && (this._just_changed =! 0)}), x.event.add (this, "click._change" , fonction (e) {this._just_changed &&! e.isTrigger && (this._just_changed =! 1), x.event.simulate ("change", this, e,! 0)})),! 1) :( x. event.add (this, "beforeactivate._change", fonction (e) {var t = e.target; Z.test (t.nodeName) &&! x._data (t, "changeBubbles") && (x.event. add (t, "change._change", fonction (e) {! this.parentNode || e.isSimulated || e.isTrigger || x.event.simulate ("change", this.parentNode, e,! 0) }), x._data (t, "changeBubbles",! 0))}), t)}, handle: fonction (e) {var n = e.target; retourne ceci! == n || e.isSimulated | | e.isTrigger || "radio"! == n.type && "case à cocher"! == n.type? e.handleObj.handler.apply (this, arguments): t}, démontage: function () {return x.event.remove (this, "._ change") ,! Z.test (this.nodeName)}}), x.support.focusinBubbles | | x.each ({focus: "focusin", flou: "focusout"}, fonction (e, t) {var n = 0, r = fonction (e) {x.event.simulate (t, e.target, x.event.fix (e),! 0)}; x.event.special [t] = {setup: function () {0 === n ++ && a.addEventListener (e, r,! 0)}, démontage: function () {0 === - n && a.removeEventListener (e, r,! 0)}}}), x.fn.extend ({on: function (e, n, r, i, o) {{ var a, s; if ("objet" == typeof e) {"chaîne"! = typeof n && (r = r || n, n = t); pour (a dans e) ceci.on (a, n, r, e [a], o); renvoie ceci} si (null == r && null == i? (i = n, r = n = t): null == i && ("chaîne" == typede n? (i = r, r = t) :( i = r, r = n, n = t)), i ===! 1) i = ot; sinon si (! i) retourne ceci; retourne 1 === o && ( s = i, i = fonction (e) {retourne x (). off (e), s.apply (ceci, arguments)}, i.guid = s.guid || (s.guid = x.guid ++)), this.each (function () {x.event.add (this, e, i, r, n)})}, un: fonction (e, t, n, r) {retourne ceci.on (e, t, n, r, 1)}, off: fonction (e, n, r) {var i, o; si (e && e.preventDefault && e.handleObj) retourne i = e .handleObj, x (e.delegateTarget) .off (i.namespace? i.origType + "." + i.namespace: i.origType, i.selector, i.handler), this; if ("objet" == typeof e) {pour (o dans e) this.off (o, n, e [o]); retourne ceci} return (n ===! 1 || "fonction" == typeof n) && (r = n, n = t), r ===! 1 && (r = ot), this.each (function () {x.event.remove (this, e, r, n)})}, déclencheur: function (e, t ) {retour this.each (function () {x.event.trigger (e, t, this)})}, triggerHandler: function (e, n) {var r = this [0]; retourne r? x.event .trigger (e, n, r,! 0): t}}; var st = / ^. [^: # \ [\,] * $ /, lt = / ^ (?: parents | prev (? : Until | All)) / / ut = x.expr.match.needsContext, ct = {enfants:! 0, contenu:! 0, suivant:! 0, prev:! 0}; x.fn.extend ({find: function (e) {var t, n = [], r = ceci, i = r.longueur; if ("string"! = typeof e) retourne ceci.pushStack (x (e) .filter ( function () {pour (t = 0; i> t; t ++) if (x.contains (r [t], this)) return! 0})); pour (t = 0; i> t; t ++) x .find (e, r [t], n); retourne n = this.pushStack (i> 1? x.unique (n): n), n.selector = this.selector? this.selector + "" + e: e, n}, a: fonction (e) {var t, n = x (e, ceci), r = longueur.neure; retourne ceci.filtre (fonction () {pour (t = 0; r> t; t ++ ) if (x.contains (this, n [t])) return! 0})}, pas: function (e) {renvoie this.pushStack (ft (this, e || [!,! 0))}}, filter: function (e) {return this.pushStack (ft (this, e || [],! 1))}} est: function (e) {return !! ft (this, "string" == typeof e && ut. test (e)? x (e): e || [],! 1) .length}, le plus proche: fonction (e, t) {var n, r = 0, i = ceci.longueur, o = [], a = ut.test (e) || "chaîne"! = type d'e x (e, t || ce.context): 0; pour (; i> r; r ++) pour (n = this [r]; n && n! == t; n = n.parentNode) if (11> n.nodeType && (a? a.index (n)> - 1: 1 === n.nodeType && x.find.matchesSelector (n, e))) {n = o.push (n); break} retourne this.pushStack (o.length> 1? x.unique (o): o)}, index: fonction (e) {retour e? "chaîne" == typede e? x.inArray (this [0] , x (e)): x.inArray (e.jquery? e [0]: e, this): this [0] && this [0] .parentNode? this.first (). prevAll (). length: -1 }, ajouter: fonction (e, t) {var n = "chaîne" == typede e? x (e, t): x.makeArray (e && e.nodeType? [e]: e), r = x.merge ( this.get (), n); renvoie this.pushStack (x.unique (r))}, addBack: function (e) {retourne this.add (null == e? this.prevObject: this.prevObject.filter ( e))}}); function pt (e, t) {do e = e [t]; tandis que (e && 1! == e.nodeType); retourne e} x.each ({parent: fonction (e) {var t = e.parentNode; retourne t && 11! == t.nodeType? t: null}, parents: fonction (e) {retourne x.dir (e, "parentNode")}, parentsUntil: fonction (e, t,n) {return x.dir (e, "parentNode", n)}, next: fonction (e) {return pt (e, "nextSibling")}, prev: fonction (e) {return pt (e, "previousSibling ")}, nextAll: function (e) {return x.dir (e," nextSibling ")}, prevAll: function (e) {return x.dir (e," previousSibling ")}, nextUntil: function (e, t, n) {return x.dir (e, "nextSibling", n)}, prevUntil: function (e, t, n) {return x.dir (e, "previousSibling", n)}, frères et soeurs: function ( e) {return x.sibling ((e.parentNode || {}). firstChild, e)}, enfants: fonction (e) {return x.sibling (e.firstChild)}, contenu: function (e) {return x.nodeName (e, "iframe")? e.contentDocument || e.contentWindow.document: x.merge ([], e.childNodes)}}, fonction (e, t) {x.fn [e] = function (n, r) {var i = x.map (this, t, n); retourne "jusqu'à"! == e.slice (-5) && (r = n), r && "chaîne" == typeof r && (i = x.filter (r,i)), this.length> 1 && (ct [e] || (i = x.unique (i)), lt.test (e) && (i = i.reverse ())), this.pushStack (i )}}), x.extend ({filtre: fonction (e, t, n) {var r = t [0]; retourne n && (e = ": pas (" + e + ")"), 1 === t.length && 1 === r.nodeType? x.find.matchesSelector (r, e)? [r]: []: x.find.matches (e, x.grep (t, fonction (e) {return 1 = == e.nodeType}))}, dir: function (e, n, r) {var i = [], o = e [n]; tant que (o && 9! == o.nodeType && (r === t | | 1! == o.nodeType ||! X (o) .is (r))) 1 === o.nodeType && i.push (o), o = o [n]; return i}, frère: fonction ( e, t) {var n = []; pour (; e; e = e.nextSibling) 1 === e.nodeType && e! == t && n.push (e); renvoyer n}}); fonction ft (e, t, n) {si (x.isFunction (t)) renvoie x.grep (e, fonction (e, r) {retour !! t.call (e, r, e)! == n}); si ( t.nodeType) retourne x.grep (e, fonction (e) {retour e === t! == n}); if ("chaîne" == typeof t) {if (st.test (t)) retourne x.filtre (t, e, n); t = x.filtre (t, e)} retourne x.grep (e, fonction (e) {retourne x.inArray (e, t)> = 0! == n})} fonction dt (e) {var t = ht.split ("|"), n = e.createDocumentFragment (); if (n.createElement) while (t.length) n.createElement (t.pop ()); renvoie n} var ht = "abbr | article | apart | audio | bdi | canvas | data | datalist | details | figcaption | figure | footer | header | hgroup | mark | mètre | nav | sortie | section | résumé | heure | vidéo ", gt = / jQuery \ d + =" ( ?: null | \ d +) "/ g, mt = RegExp (" <(?: "+ ht +") [\\ s />] "," i "), yt = / ^ \ s + /, vt = / <(?! area | br | col | embed | hr | img | input | link | meta | param) (([\ w:] +) [^>] *) \ /> / gi, bt = / <( [\ w:] +) /, xt = / <tbody / i, wt = / <| & #? \ w +; /, Tt = / <(?: script | style | lien) / i, Ct = / ^ (?: case à cocher | radio) $ / i, Nt = / vérifié \ s * (?: [^ =] | = \ s *. cochée.) / i, kt = / ^ $ | \ / (?: java | ecma) script / i, Et = / ^ vrai \ / (. *) /, St = / ^ \ s * <! (?: \ [CDATA \ [| -) | (?: \] \] | - -)> \ s * $ / g,At = {option: [1, "<select multiple = 'multiple'>", "</ select>"], légende: [1, "<fieldset>", "</ fieldset>"], zone: [1 , "<map>", "</ map>"], param: [1, "<objet>", "</ object>"], thead: [1, "<table>", "</ table> "], tr: [2," <table> <tbody> "," </ tbody> </ table> "], col: [2," <table> <tbody> </ tbody> <colgroup> ", "</ colgroup> </ table>"], td: [3, "<table> <tbody> <tr>", "</ tr> </ tbody> </ table>"], _ défaut: x.support .htmlSerialize? [0, "", ""]: [1, "X <div>", "</ div>"]}, jt = dt (a), Dt = jt.appendChild (a.createElement (" div ")); At.optgroup = At.option, At.tbody = At.tfoot = At.colgroup = At.caption = At.thead, At.th = At.td, x.fn.extend ({texte: fonction (e) {retour x .access (this, fonction (e) {return e === t? x.text (this): this.empty (). append ((this [0] && this [0] .ownDocument || a) .createTextNode ( e))}, null, e, arguments.length)}, append: function () {return this.domManip (arguments, function (e) {if (1 === this.nodeType || 11 === this. nodeType || 9 === this.nodeType) {var t = Lt (this, e); t.appendChild (e)}})}, prepend: function () {retour this.domManip (arguments, fonction (e) {if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {var t = Lt (ceci, e); t.insertBefore (e, t.firstChild) }})}, before: function () {return this.domManip (arguments, function (e) {this.parentNode && this.parentNode.insertBefore (e, this)})}, après: function () {return this.domManip ( arguments, fonction (e) {this.parentNode && this.parentNode.insertBefore (e,this.nextSibling)})}, remove: function (e, t) {var n, r = e? x.filter (e, this): ceci, i = 0; pour (; null! = (n = r [ i]); i ++) t || 1! == n.nodeType || x.cleanData (Ft (n)), n.parentNode && (t && x.contains (n.ownerDocument, n) && _ t (Ft (n, "script" ")), n.parentNode.removeChild (n)); retourne ceci}, empty: function () {var e, t = 0; pour (; null! = (e = ceci [t]); t ++) {1 === e.nodeType && x.cleanData (Ft (e,! 1)); tandis que (e.firstChild) e.removeChild (e.firstChild); e.options && x.nodeName (e, "select") && (e.options .length = 0)} retourne ceci}, clone: ​​fonction (e, t) {retourne e = null == e?! 1: e, t = null == t? e: t, this.map (function () {return x.clone (this, e, t)})}, html: function (e) {return x.access (this, function (e) {var n = this [0] || {}, r = 0 , i = this.length; if (e === t) renvoie 1 === n.nodeType? n.innerHTML.replace (gt, ""): t; if (! ("chaîne"!! = typede e | | Tt.test (e) ||! X.support.htmlSerialize && mt.test (e) ||! x.support.leadingWhitespace && yt.test (e) || Dans [(bt.exec (e) || ["", ""]) [1] .toLowerCase ()]) {e = e.replace (vt, "<$ 1> </ $ 2>"); essayez {pour (; i> r; r ++) n = this [r] || {}, 1 === n.nodeType && ( x.cleanData (Ft (n,! 1)), n.innerHTML = e); n = 0} catch (o) {}} n && this.empty (). append (e)}, null, e, arguments.length )}, replaceWith: function () {var e = x.map (this, fonction (e) {return [e.nextSibling, e.parentNode]}), t = 0; renvoie this.domManip (arguments, fonction (n ) {var r = e [t ++], i = e [t ++]; i && (r && r.parentNode! == i && (r = this.nextSibling), x (ceci) .remove (), i.insertBefore (n, r ))},! 0), ceci: ceci.remove ()}, détachez: fonction (e) {retourne ceci.remove (e,! 0)}, domManip: fonction (e, t, n) {e = d.apply ([], e); varr, i, o, a, s, l, u = 0, c = ceci.longueur, p = ceci, f = c-1, h = e [0] , g = x.isFunction (h); if (g ||! (1> = c || "chaîne"!= typeof h || x.support.checkClone) && Nt.test (h)) renvoie this.each (fonction (r) {var i = p.eq (r); g && (e [0] = h.call (this , r, i.html ())), i.domManip (e, t, n)}); if (c && (l = x.buildFragment (e, ce [0] .ownDocument,! 1,! n && this), r = l.firstChild, 1 === l.childNodes.length && (l = r), r)) {pour (a = x.map (Ft (l, "script"), Ht), o = a.length ; c> u; u ++) i = l, u! == f && (i = x.clone (i,! 0,! 0), o && x.merge (a, Ft (i, "script")), t .call (this [u], i, u); if (o) pour (s = a [longueur.a1] .ownerDocument, x.map (a, qt), u = 0; o> u; u ++ ) i = a [u], kt.test (i.type || "") &&! x._data (i, "globalEval") && x.contains (s, i) && (i.src? x._evalUrl ( i.src): x.globalEval ((i.text || i.textContent || i.innerHTML || ""). replace (St, ""))); l = r = null} renvoie ceci}}) ; fonction Lt (e, t) {return x.nodeName (e, "table") && x.nodeName (1 === t.nodeType? t: t.firstChild, "tr")? e.getElementsByTagName ("tbody") [0] || e.appendChild (e.ownerDocument.createElement ("tbody")): e} fonction Ht (e) {retourne e.type = (null! == x.find.attr (e, "type")) + "/" + e.type, e} fonction qt (e) {var t = Et.exec (type e); retourne t? E.type = t [1]: e.removeAttribute ("type"), e} fonction _t (e, t) {var n, r = 0; pour ( ; null! = (n = e [r]); r ++) x._data (n, "globalEval",! t || x._data (t [r], "globalEval"))} fonction Mt (e, t ) {if (1 === t.nodeType && x.hasData (e)) {var n, r, i, o = x._data (e), a = x._data (t, o), s = o.events ; if (s) {delete a.handle, a.events = {}; pour (n en s) pour (r = 0, i = s [n] .length; i> r; r ++) x.event.add (t, n, s [n] [r])} a.data && (a.data = x.extend ({}, a.data))}} fonction Ot (e, t) {var n, r, i ; if (1 === t.nodeType) {if (n = t.nodeName.toLowerCase (),! x.support.noCloneEvent && t [x.expando]) {i = x._data (t); pour (r dans i.events) x.removeEvent (t, r, i.handle); t.removeAttribute (x.expando)} "script" === n && t .text! == e.text? (Ht (t) .text = e.text, qt (t)): "objet" === n? (t.parentNode && (t.outerHTML = e.outerHTML), x .support.html5Clone && e.innerHTML &&! x.trim (t.innerHTML) && (t.innerHTML = e.innerHTML)): "input" === n && Ct.test (e.type)? (t.defaultChecked = t.check = e.checked, t.value! == e.value && (t.value = e.value)): "option" === n? t.defaultSelected = t.selected = e.defaultSelected :( "input" = == n || "textarea" === n) && (t.defaultValue = e.defaultValue)}} x.each ({appendTo: "append", prependTo: "prepend", insertBefore: "avant", insertAfter: "après", replaceAll: "replaceWith"}, fonction (e, t) {x.fn [e] = fonction (e) {var n, r = 0, i = [],o = x (e), a = o.longueur-1; pour (; a> = r; r ++) n = r === a? ceci: ceci.clone (! 0), x (o [r]) [t] (n), h.apply (i, n.get ()); renvoie this.pushStack (i)}}); fonction Ft (e, n) {varr, o, a = 0, s = typeof e.getElementsByTagName! == i? e.getElementsByTagName (n || "*"): typeof e.querySelectorAll! == i? e.querySelectorAll (n || "*"): t; si (! s) pour (s = [], r = no.childnodes || e; null! = (o = r [a]); a ++)! n || x.nodeName (o, n)? s.push (o): x .merge (s, Ft (o, n)); retourne n === t || n && x.nodeName (e, n)? x.merge ([e], s): s} fonction Bt (e) {Ct .test (e.type) && (e.defaultChecked = e.checked)} x.extend ({clone: ​​function (e, t, n) {var r, i, o, a, s, l = x.contient (e.ownerDocument, e); if (x.support.html5Clone || x.isXMLDoc (e) ||! mt.test ("<" + e.nodeName + ">")? o = e.cloneNode (! 0 ) :( Dt.innerHTML = e.outerHTML, Dt.removeChild (o = Dt.firstChild)),! (X.support.noCloneEvent && x.support.noCloneChecked || 1! == e.nodeType && 11! == e.nodeType || x.isXMLDoc (e))) pour (r = Ft (o), s = Ft (e), a = 0; null! = (I = s [a]); + + a) r [a] && Ot (i, r [a]); si (t) si (n) pour (s = s || Ft (e), r = r || Ft (o), a = 0 ; null! = (i = s [a]); a ++) Mt (i, r [a]); sinon Mt (e, o); renvoyer r = Ft (o, "script"), r.longueur> 0 && _ t (r,! l && Ft (e, "script")), r = s = i = null, o}, buildFragment: fonction (e, t, n, r) {var i, o, a, s, l, u , c, p = longueur e, f = dt (t), d = [], h = 0; pour (; p> h; h ++) si (o = e [h], o || 0 === o) si ("objet" === x.type (o)) x.merge (d, o.nodeType? [o]: o); sinon si (wt.test (o)) {s = s || f.appendChild (t.createElement ("div")), l = (bt.exec (o) || ["", ""]) [1] .toLowerCase (), c = At ​​[l] || At ._default, s.innerHTML = c [1] + remplacement (vt, "<$ 1> </ $ 2>") + c [2], i = c [0]; tandis que (i -) s = s .lastChild; if (! x.support.leadingWhitespace && yt.test (o) && d.push (t.createTextNode (yt.exec (o) [0])), {x.support.tbody) {o = "table "! == l || xt.test (o)?" <table> "! == c [1] || xt.test (o)? 0: s: s.firstChild, i = o && o.childNodes. longueur; tandis que (i -) x.nodeName (u = o.childNodes [i], "tbody") &&! u.childNodes.length && o.removeChild (u)} x.merge (d, s.childNodes), s .textContent = ""; while (s.firstChild) s.removeChild (s.firstChild); s = f.lastChild} else d.push (t.createTextNode (o)); s && f.removeChild (s), x.support .appendChecked || x.grep (Ft (d, "entrée"), Bt), h = 0; tant que (o = d [h ++]) if ((! r || -1 === x.inArray (o , r)) && (a = x.contains (o.ownerDocument, o), s = Ft (f.appendChild (o), "script"), a && _ t (s), n)) {i = 0; while ( o = s [i ++]) kt.test (o.type || "") && n.push (o)} renvoie s = null, f}, cleanData: fonction (e, t) {var n, r, o, a, s = 0, l = x.expando, u = x.cache, c = x.support.deleteExpando, f = x.event.special; pour (; null! = (n = e [s]); s ++ ) si ((t || x.acceptData (n)) && (o = n [l], a = o && u [o])) {if (a.events) pour (r dans a.events) f [r]? x.event.remove (n, r): x.removeEvent (n, r, a.handle);
u [o] && (supprimer u [o], c? supprimer n [l]: type de n.removeAttribute! == i? n.removeAttribute (l): n [l] = null, p.push (o)) }}, _ evalUrl: function (e) {return x.ajax ({url: e, type: "GET", dataType: "script", async:! 1, global:! 1, "jette":! 0}) }}), x.fn.extend ({wrapAll: fonction (e) {if (x.isFunction (e))) renvoie this.each (fonction (t) {x (this) .wrapAll (e.call (this, t))}); if (this [0]) {var t = x (e, this [0] .ownerDocument) .eq (0) .clone (! 0); this [0] .parentNode && t.insertBefore (this [0]), t.map (function () {var e = this; tandis que (e.firstChild && 1 === e.firstChild.nodeType) e = e.firstChild; retourne e}). Append (this)} retourne ceci }, wrapInner: function (e) {return x.isFunction (e)? this.each (fonction (t) {x (this) .wrapInner (e.call (this, t))}): this.each (fonction () {var t = x (this), n = t.contents (); n.length? n.wrapAll (e): t.append (e)})}, wrap: function (e) {var t = x.isFunction (e); retourne ceci.each (function (n) {x (this) .wrapAll (t? e.call (this, n): e)})}, unwrap: function () {renvoie this.parent (). each (function () { x.nodeName (this, "body") || x (this) .replaceWith (this.childNodes)}). end ()}}); var Pt, Rt, Wt, $ t = / alpha \ ([^) ] * \) / i, Il = / opacité \ s * = \ s * ([^)] *) /, zt = / ^ (haut | droite | bas | gauche) $ /, Xt = / ^ (aucun | table (?! - c [ea]). +) /, Ut = / ^ marge /, Vt = RegExp ("^ (" + w + ") (. *) $", "i"), Yt = RegExp ( "^ (" + w + ") (?! px) [az%] + $", "i"), Jt = RegExp ("^ ([+ -]) = (" + w + ")", "i" ), Gt = {BODY: "block"}, Qt = {position: "absolute", visibilité: "hidden", display: "block"}, Kt = {letterSpacing: 0, fontWvar Pt, Rt, Wt, $ t = / alpha \ ([^)] * \) / i, It = / opacité \ s * = \ s * ([^)] *) /, zt = / ^ (haut de la page | right | bottom | left) $ /, Xt = / ^ (aucun | table (?! - c [ea]). +) /, Ut = / ^ marge /, Vt = RegExp ("^ (" + w + " ) (. *) $ "," i "), Yt = RegExp (" ^ ("+ w +") (?! px) [az%] + $ "," i "), Jt = RegExp (" ^ ( [+ -]) = ("+ w +") "," i "), Gt = {BODY:" bloc "}, Qt = {position:" absolu ", visibilité:" masqué ", affichage:" bloc "} , Kt = {letterSpacing: 0, fontWvar Pt, Rt, Wt, $ t = / alpha \ ([^)] * \) / i, It = / opacité \ s * = \ s * ([^)] *) /, zt = / ^ (haut de la page | right | bottom | left) $ /, Xt = / ^ (aucun | table (?! - c [ea]). +) /, Ut = / ^ marge /, Vt = RegExp ("^ (" + w + " ) (. *) $ "," i "), Yt = RegExp (" ^ ("+ w +") (?! px) [az%] + $ "," i "), Jt = RegExp (" ^ ( [+ -]) = ("+ w +") "," i "), Gt = {BODY:" bloc "}, Qt = {position:" absolu ", visibilité:" masqué ", affichage:" bloc "} , Kt = {letterSpacing: 0, fontWabsolu ", visibilité:" masqué ", affichage:" bloc "}, Kt = {letterSpacing: 0, fontWabsolu ", visibilité:" masqué ", affichage:" bloc "}, Kt = {letterSpacing: 0, fontWhuit: 400}, Zt = ["Haut", "Droite", "Bas", "Gauche"], en = ["Webkit", "O", "Moz", "ms"]; fonction tn (e, t) {si (t dans e) renvoie t; var n = t.charAt (0) .toUpperCase () + t.slice (1), r = t, i = en.longueur; tandis que (i -) si (t = en [i] + n, t dans e) retourne t; retourne r} fonction nn (e, t) {retourne e = t || e, "aucun" === x.css (e, "display ") ||! x.contient (e.ownerDocument, e)} fonction rn (e, t) {var n, r, i, o = [], a = 0, s = e.longueur; pour (; s > a; a ++) r = e [a], r.style && (o [a] = x._data (r, "olddisplay"), n = r.style.display, t? (o [a] || " none "! == n || (r.style.display =" ")," "=== r.style.display && nn (r) && (o [a] = x._data (r," olddisplay ", ln (r.nodeName)))): o [a] || (i = nn (r), (n && "aucun"! == n ||! i) && x._data (r, "olddisplay", i? n : x.css (r, "display"))));pour (a = 0; s> a; a ++) r = e [a], r.style && (t && "none"! == r.style.display && ""! == r.style.display || (r. style.display = t? o [a] || "": "aucun")); retour e} x.fn.extend ({css: fonction (e, n) {retour x.access (this, fonction (e , n, r) {var i, o, a = {}, s = 0; si (x.isArray (n)) {pour (o = Rt (e), i = n.longueur; i> s; s ++ ) a [n [s]] = x.css (e, n [s],! 1, o); retourne a} retour r! == t? x.style (e, n, r): x.css (e, n)}, e, n, arguments.length> 1)}, show: function () {return rn (this,! 0)}, masquer: function () {return rn (this)}, bascule: function (e) {return "boolean" == typeof e? e? this.show (): this.hide (): this.each (fonction () {nn (this)? x (this) .show (): x (this) .hide ()}}}), x.extend ({cssHooks: {opacity: {get: function (e, t) {if (t) {var n = Wt (e, "opacity") ; return "" === n? "1": n}}}}, cssNumber: {columnCount:! 0, fillOpacity:! 0, fontWeight:! 0, lineHeight:! 0, opacité:! 0,order:! 0, orphelins:! 0, veuves:! 0, zIndex:! 0, zoom:! 0}, cssProps: {"float": x.support.cssFloat? "cssFloat": "styleFloat"}, style: fonction (e, n, r, i) {si (e && 3! == e.nodeType && 8! == e.nodeType && e.style) {var o, a, s, l = x.camelCase (n), u = e. style; si (n = x.cssProps [l] || (x.cssProps [l] = tn (u, l)), s = x.cssHooks [n] || x.cssHooks [l], r == = t) retourne s && "get" dans s && (o = s.get (e,! 1, i))! == t? o: u [n]; if (a = typeof r, "chaîne" === a && (o = Jt.exec (r)) && (r = (o [1] +1) * o [2] + parseFloat (x.css (e, n)), a = "nombre"),! ( null == r || "nombre" === a && isNaN (r) || ("nombre"! == a || x.cssNumber [l] || (r + = "px"), x.support.clearCloneStyle | | ""! == r || 0! == n.indexOf ("background") || (u [n] = "inherit"), s && "set" dans s && (r = s.set (e, r ,i)) === t))) essayer {u [n] = r} attraper (c) {}}}, css: fonction (e, n, r, i) {var o, a, s, l = x.camelCase (n); return n = x.cssProps [l] || (x.cssProps [l] = tn (style e, l)), s = x.cssHooks [n] || x.cssHooks [ l], s && "get" dans s && (a = s.get (e,! 0, r)), a === t && (a = Wt (e, n, i)), "normal" === a && n en Kt && (a = Kt [n]), "" === r || r? (o = parseFloat (a), r ===! 0 || x.isNumeric (o)? o || 0: a ): a}}), e.getComputedStyle? (Rt = fonction (t) {retour e.getComputedStyle (t, null)}, Wt = fonction (e, n, r) {var i, o, a, s = r || Rt (e), l = s? s.get.PropertyValue (n) || s [n]: t, u = e.style; retourne s && (""!! == l || x.contains (e. ownerDocument, e) || (l = style de style (e, n)), Yt.test (l) && Ut.test (n) && (i = largeur de la souris, o = largeur de la minute, a = largeur de la largeur , u.minWidth = u.maxWidth = u.width = l, l = s.width, u.width = i, u.minWidth = o, u.maxWidth = a)), l}): a.documentElement.currentStyle && (Rt = fonction (e) {retourne e.currentStyle}, Wt = fonction (e, n, r) {var i, o, a, s = r || Rt (e), l = s? s [n]: t, u = e.style; retourne null == l && u && u [n] && (l = u [n]), Yt.test (l) &&! zt.test (n) && (i = u.left, o = e.runtimeStyle, a = o && o.left, a && (o.left = e.currentStyle.left), u.left = "fontSize" === n? "1em": l, l = u.pixelLeft + "px", u.left = i, a && (o. left = a)), "" === l? "auto": l}); fonction activée (e, t, n) {var r = Vt.exec (t); retourne r? Math.max (0, r [1] - (n || 0)) + (r [2] || "px"): t} fonction an (e, t, n, r, i) {var o = n === (r ? "border": "content")? 4: "largeur" ​​=== t? 1: 0, a = 0; pour (; 4> o; o + = 2) "marge" === n && (a + = x .css (e, n + Zt [o],! 0, i)), r? ("contenu" === n && (a- = x.css (e, "remplissage" + Zt [o],! 0 , i)), "marge"! == n && (a- = x.css (e, "bordure" + Zt [o] + "largeur",! 0,i)):: a + = x.css (e, "remplissage" + Zt [o],! 0, i), "remplissage"! == n && (a + = x.css (e, "bordure" + Zt [o] + "Largeur",! 0, i))); retourne une fonction} sn (e, t, n) {var r =! 0, i = "largeur" ​​=== t? e.offsetWidth: e .offsetHeight, o = Rt (e), a = x.support.boxSizing && "border-box" === x.css (e, "boxSizing",! 1, o); if (0> = i || null == i) {si (i = Wt (e, t, o), (0> i || null == i) && (i = e.style [t]), Yt.test (i)) renvoie i ; r = a && (x.support.boxSizingReliable || i === e.style [t]), i = parseFloat (i) || 0} renvoie i + an (e, t, n || (a? " bordure ":" contenu "), r, o) +" px "} fonction ln (e) {var t = a, n = Gt [e]; retourne n || (n = un (e, t)," none "! == n && n || (Pt = (Pt || x (" iframe frameborder = "0") width = "0" height = "0" /> "). css (" cssText "," display: block ! important ")). appendTo (t.documentElement), t = (Pt [0] .contentWindow || Pt [0] .contentDocument) .document, t.write ("<! doctype html> <html> <body>"), t.close (), n = un (e, t), Pt.detach ()), Gt [e] = n), n} fonction un (e, t) {var n = x (t.createElement (e)). appendTo (t. body), r = x.css (n [0], "display"); retourne n.remove (), r} x.each (["hauteur", "largeur"], fonction (e, n) {x .cssHooks [n] = {get: function (e, r, i) {return r? 0 === e.offsetWidth && Xt.test (x.css (e, "display"))? x.swap (e, Qt , function () {return sn (e, n, i)}): sn (e, n, i): t}, set: fonction (e, t, r) {var i = r && Rt (e); retourne sur (e, t, r? an (e, n, r, x.support.boxSizing && "border-box" === x.css (e, "boxSizing",! 1, i), i): 0)} }}), x.support.opacity || (x.cssHooks.opacity = {get: function (e, t) {return It.test ((t && e.currentStyle? e.currentStyle.filter: e.style.filter) || ""?01 * parseFloat (RegExp. $ 1) + "": t? "1": ""}, définissez: fonction (e, t) {var n = style e., R = e.currentStyle, i = x.isNumeric ( t)? "alpha (opacité =" + 100 * t + ")": "", o = r && r.filter || n.filter || ""; n.zoom = 1, (t> = 1 || "" === t) && "" === x.trim (o.replace ($ t, "")) && n.removeAttribute && (n.removeAttribute ("filtre"), "" === t || r &&! r .filter) || (n.filter = $ t.test (o)? o.replace ($ t, i): o + "" + i)}}), x (fonction () {x.support.reliableMarginRight | | (x.cssHooks.marginRight = {get: fonction (e, n) {retourne n? x.swap (e, {display: "bloc en-ligne"}, Wt, [e, "marginRight"]): t} x.support.pixelPosition && x.fn.position && x.each (["top", "left"], fonction (e, n) {x.cssHooks [n] = {obtenir: fonction (e, r) { retourne r? (r = Wt (e, n), Yt.test (r)? x (e) .position () [n] + "px": r): t}}})}), x.expr && x.expr.filters && (x.expr.filters.hidden = fonction ( e) {return 0> = e.offsetWidth && 0> = e.offsetHeight ||! x.support.reliableHiddenOffsets && "none" === (e.style && e.style.display || x.css (e, "display")) }, x.expr.filters.visible = fonction (e) {return! x.expr.filters.hidden (e)}), x.each ({margin: "", padding: "", bordure: "largeur" }, fonction (e, t) {x.cssHooks [e + t] = {développer: fonction (n) {var r = 0, i = {}, o = "chaîne" == type de n? n.split ( ""): [n]; pour (; 4> r; r ++) i [e + Zt [r] + t] = o [r] || o [r-2] || o [0]; retourne i }}, Ut.test (e) || (x.cssHooks [e + t] .set = on)}); var cn = /% 20 / g, pn = / \ [\] $ /, fn = / \ r? \ n / g, dn = / ^ (?: envoyer | bouton | image | reset | fichier) $ / i, hn = / ^ (?: entrée | sélectionner | textarea | keygen) /i;x.fn .extend ({serialize: function () {return x.param (this.serializeArray ())}, serializeArray: function () {return this.map (function () {var e = x.prop (this, "elements"); retour e? x.makeArray (e): this}). filter (function () {var e = this.type; renvoyer this.name &&! x (this) .is (": disabled") && hn.test (this.nodeName) &&! dn.test (e) && (this.checked ||! Ct.test (e))}). Map (fonction (e, t) {var n = x (this) .val (); retourne null == n? Null: x.isArray (n)? X .map (n, fonction (e) {return {nom: t.nom, valeur: e.replace (fn, "\ r \ n")}}): {nom: t.nom, valeur: n.replace ( fn, "\ r \ n")}}. get ()}}), x.param = fonction (e, n) {varr, i = [], o = fonction (e, t) {t = x.isFunction (t)? t (): null == t? "": t, i [longueur.i] = encodeURIComponent (e) + "=" + encodeURIComponent (t)}; if (n === t && (n = x.ajaxSettings && x.ajaxSettings.traditional), x.isArray (e) || e.jquery &&! x.isPlainObject (e)) x.each (e, fonction () {o (this.name, this.value)}); else pour (r dans e) gn (r, e [r], n, o); retourne i.join ("&"). remplace (cn, "+")}; fonction gn (e, t, n, r) {var i; if (x.isArray (t)) x.each (t, fonction (t, i) {n || pn.test (e)? r (e , i): gn (e + "[" + ("objet" == type of i? t: "") + "," i, n, r)}); sinon si (n || "objet"! = = x.type (t)) r (e, t); sinon pour (i dans t) gn (e + "[" + i + "]", t [i], n, r)} x.each ("flou" focus focusin focusout charger redimensionner défiler défiler cliquer dblclick mousedown mouseup déplacer souris mouseover déplacer souris mouseover souris déplacer changer sélection soumettre soumettre touche bas touche presse erreur contextuelle menu .split (""), fonction (e, t) {x.fn [t] = fonction (e, n) {return arguments.length> 0? this.on (t, null, e, n): this.trigger (t)}}), x.fn.extend ({survol: fonction (e, t) {return this.mouseenter (e) .mouseleave (t || e)}, lien: fonction (e, t, n) {retourne this.on (e, null,t, n)}, non lié: fonction (e, t) {retourne this.off (e, null, t)}, délégué: fonction (e, t, n, r) {retourne this.on (t, e, n, r)}, undelegate: function (e, t, n) {retourne 1 === arguments.length? this.off (e, "**"): this.off (t, e || "** ", n)}}); var mn, yn, vn = x.now (), bn = / \? /, xn = / #. * $ /, wn = / ([? &]) _ = [^ &] * /, Tn = / ^ (. *?): [\ T] * ([^ \ r \ n] *) \ r? $ / Gm, Cn = / ^ (?: à propos de | app | app- stockage |. + - extension | fichier | res | widget): $ /, Nn = / ^ (?: GET | HEAD) $ /, kn = / ^ \ / \ //, En = / ^ ([\ w. + -] +:) (?: \ / \ / ([^ \ /? #:] *) (? :: (\ d +) |) |) /, Sn = x.fn.load, An = {} , jn = {}, Dn = "* /". concat ("*"); essayer {yn = o.href} attraper (Ln) {yn = a.createElement ("a"), yn.href = "" , yn = yn.href} mn = En.exec (yn.toLowerCase ()) || []; fonction Hn (e) {fonction de retour (t, n) {"chaîne"! = typede t && (n = t, t = "*"); var r, i = 0, o = t.toLowerCase (). match (T) || []; if (x.isFunction (n)) while (r = o [i ++]) " + "=== r [0]? (r = r.tranche (1) || "*", (e [r] = e [r] || []). unshift (n)) :( e [r] = e [r] || []). push ( n)}} fonction qn (e, n, r, i) {var o = {}, a = e === jn; fonction s (l) {var u; retour o [l] =! 0, x. chaque (e [l] || [], fonction (e, l) {var c = l (n, r, i); retourne "chaîne"! = type de c || a || o [c]? a? ! (u = c): t: (n.dataTypes.unshift (c), s (c),! 1)}), u} retourne s (n.dataTypes [0]) ||! o ["*" ] && s ("*")} function _n (e, n) {var r, i, o = x.ajaxSettings.flatOptions || {}; pour (i en n) n [i]! == t && ((o [i]? e: r || (r = {})) [i] = n [i]); retourne r && x.extend (! 0, e, r), e} x.fn.load = fonction (e , n, r) {if ("chaîne"! = typede e && Sn) renvoie Sn.apply (ceci, arguments); var i, o, a, s = ceci, l = e.indexOf (""); renvoie l> = 0 && (i = e.slice (l, e.longueur), e = e.slice (0, l)), x.isFunction (n)? (R = n, n = t): n && "objet" = = typeof n && (a = "POST"), de longueur> 0 && x.ajax ({url: e, type: a,dataType: "html", data: n}). done (fonction (e) {o = arguments, s.html (i? x ("<div>"). append (x.parseHTML (e)). find ( i): e)}). complete (r && fonction (e, t) {s.each (r, o || [e.responseText, t, e])}), this}, x.each (["ajaxStart" , "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], fonction (e, t) {x.fn [t] = fonction (e) {renvoie this.on (t, e) }}), x.extend ({active: 0, lastModified: {}, etag: {}, ajaxSettings: {url: yn, tapez: "GET", isLocal: Cn.test (mn [1]), global: ! 0, processData:! 0, async:! 0, contentType: "application / x-www-form-urlencoded; charset = UTF-8", accepte: {"*": Dn, texte: "text / plain", html: "text / html", xml: "application / xml, text / xml", json: "application / json, text / javascript"}, contenu: {xml: / xml /, html: / html /, json: / json /},responseFields: {xml: "responseXML", text: "responseText", json: "responseJSON"}, convertisseurs: {"* text": String, "text html":! 0, "text json": x.parseJSON, " text xml ": x.parseXML}, flatOptions: {url:! 0, contexte:! 0}}, ajaxSetup: fonction (e, t) {retourne t? _n (_n (e, x.ajaxSettings), t): _n (x.ajaxSettings, e)}, ajaxPrefilter: Hn (An), ajaxTransport: Hn (jn), ajax: fonction (e, n) {"objet" == typede e && (n = e, e = t), n = n || {}; var, i, o, a, s, l, u, c, p = x.ajaxSetup ({}, n), f = p.context || p, d = p. contexte && (f.nodeType || f.jquery)? x (f): x.event, h = x.Deferred (), g = x.Callbacks ("une fois en mémoire"), m = p.statusCode || {} , y = {}, v = {}, b = 0, w = "annulé", C = {readyState: 0, getResponseHeader: fonction (e) {var t; if (2 === b) {if (! c) {c = {}; tandis que (t = Tn.exec (a)) c [t [1] .toLowerCase ()] = t [2]} t = c [e.toLowerCase ()]} retour null = = t? null: t},getAllResponseHeaders: function () {return 2 === b? a: null}, setRequestHeader: function (e, t) {var n = e.toLowerCase (); retourne b || (e = v [n] = v [ n] || e, y [e] = t), ceci}, overrideMimeType: fonction (e) {retourne b || (p.mimeType = e), ceci}, code d'état: fonction (e) {var t; if (e) si (2> b) pour (t dans e) m [t] = [m [t], e [t]]; sinon C. toujours (e [C.status]); renvoyer ceci}, annuler : fonction (e) {var t = e || w; retourne u && u.abort (t), k (0, t), ceci}}; if (h.promise (C) .complete = g.add, C. success = C.done, C.error = C.fail, p.url = ((e || p.url || yn) + ""). replace (xn, ""). replace (kn, mn [1 ] + "//"), type.p = = méthode || type || méthode || type, p.dataTypes = x.trim (typeP.data || "*"). toLowerCase () .match (T) || [""], null == p.crossDomain && (r = En.exec (p.url.toLowerCase ()), p.crossDomain =! (! r || r [1] === mn [1] && r [2] === mn [2] && (r [3] || ("http:" === r [1]? "80": "443 ")) === (mn [3] || (" http: "=== mn [1]?" 80 ":" 443 "))), p.data && p.processData &&" chaîne "! = = Typeof p.data && (p.data = x.param (p.data, p.traditional)), qn (An, p, n, C), 2 === b) retourne C; l = p.global, l && 0 = == x.active ++ && x.event.trigger ("ajaxStart"), type de fichier = type.to.Chapitre (), p.hasContent =! Nn.test (type de fichier), o = p.url, p.hasContent || (p.data && (o = p.url + = (bn.test (o)? "&": "?") + p.data, supprimez p.data), p.cache ===! 1 && (p.url = wn.test (o)? O.replace (wn, "$ 1 _ =" + vn ++): o + (bn.test (o)? "&": "?") + "_ =" + vn ++)), p.ifModified && (x.lastModified [o] && C.setRequestHeader ("If-Modified-Since", x.lastModified [o]), x.etag [o] && C.setRequestHeader ("If-None- Match ", x.etag [o])), (p.data && p.hasContent && p.contentType! ==! 1 || n.contentType) && C.setRequestHeader ("Content-Type", p.contentType), C.setRequestHeader ("Accept", p.dataTypes [0] && p.accepts [p.dataTypes [0]]? P.accepts [p.dataTypes [0]] + ("*"! == p.dataTypes [0]? "," + Dn + "; q = 0.01": ""): p.accepts ["*"]); for (i in p.headers) C.setRequestHeader (i, p.headers [i]); if (p.beforeSend && (p.beforeSend.call (f, C, p) === ! 1 || 2 === b)) retourne C.abort (); w = "abort"; pour (i dans {succès: 1, erreur: 1, complet: 1}) C [i] (p [i ]); if (u = qn (jn, p, n, C)) {C.readyState = 1, l && d.trigger ("ajaxSend", [C, p]), p.async && p.timeout> 0 && (s = setTimeout (function () {C.abort ("timeout")}, p. timeout)); essayez {b = 1, u.send (y, k)} attrapez (N) {if (! (2> b) ) jettent N; k (-1, N)}} sinon k (-1, "Pas de transport"); fonction k (e, n, r,i) {var c, y, v, w, T, N = n; 2! == b && (b = 2, s && clearTimeout (s), u = t, a = i || "", C.readyState = e > 0? 4: 0, c = e> = 200 && 300> e || 304 === e, r && (w = Mn (p, C, r)), w = On (p, w, C, c), c? (p.ifModified && (T = C.getResponseHeader ("Dernière modification"), T && (x.lastModified [o] = T), T = C.getResponseHeader ("etag"), T && (x.etag [o ] = T)), 204 === e || "HEAD" === p.type? N = "nocontent": 304 === e? N = "non modifié" :( N = w.state, y = w.data, v = w.error, c =! v)) :( v = N, (e ||! N) && (N = "erreur", 0> e && (e = 0))), C. status = e, C.statusText = (n || N) + "", c? h.resolveWith (f, [y, N, C]): h.rejectWith (f, [C, N, v]), C.statusCode (m), m = t, l && d.trigger (c? "AjaxSuccess": "ajaxError", [C, p, c? Y: v]), g.fireWith (f, [C, N]) , l && (d.trigger ("ajaxComplete", [C, p]), - x.active || x.event.trigger ("ajaxStop")))} retour C}, getJSON: fonction (e, t, n) {retour x.get (e, t, n, "json")}, getScript: fonction (e, n) { renvoyer x.get (e, t, n, "script")}}), x.each (["obtenir", "post"], fonction (e, n) {x [n] = fonction (e, r , i, o) {return x.isFunction (r) && (o = o || i, i = r, r = t), x.ajax ({url: e, type: n, dataType: o, data: r, succès: i})}}); fonction Mn (e, n, r) {var i, o, a, s, l = e.contents, u = e.dataTypes; while ("*" === u [0]) u.shift (), o === t && (o = e.mimeType || n.getResponseHeader ("Content-Type")); if (o) pour (s dans l) if (l [ s] && l [s] .test (o)) {u.unshift (s); pause} if (u [0] dans r) a = u [0]; sinon {pour (s dans r) {if (! u [0] || e.convertisseurs [s + "" + u [0]]) {a = s; pause} i || (i = s)} a = a || i} retourne a? (a! = = u [0] && u.unshift (a), r [a]): t} fonction On (e, t, n, r) {var i, o, a, s, l, u = {}, c = e.dataTypes.slice (); if (c [1]) pour (a dans les convertisseurs) u [a.toLowerCase ()] = e.convertisseurs [a]; o = c.shift (); tant que (o) if (e.responseFields [o] && (n [e.responseFields [o]] = t),! l && r && e.dataFilter && (t = e.dataFilter (t, e.dataType)), l = o, o = c.shift ()) if ("*" === o) o = l; sinon if ("*"! == l && l! == o) {si (a = u [l + "" + o] || u ["*" + o] ,! a) pour (i dans u) si (s = i.split (""), s [1] = == o && (a = u [l + "" + s [0]] || u ["*" + s [0]])) {a ===! 0? a = u [i]: u [i ]! ==! 0 && (o = s [0], c.unshift (s [1])); pause} if (a! ==! 0) if (a && e ["jette"]) t = a (t ); sinon essayez {t = a (t)} catch (p) {return {état: "analyseur d'erreur", erreur: a? ​​p: "Aucune conversion de" + l + "en" + o}}} retour {état: "success", data: t}} x.ajaxSetup ({accepte: {script: "text / javascript, application / javascript, application / ecmascript, application / x-ecmascript"}, contenu: {script: / (?:java | ecma) script /}, convertisseurs: {"script de texte": fonction (e) {retour x.globalEval (e), e}}}), x.ajaxPrefilter ("script", fonction (e) {e. cache === t && (e.cache =! 1), e.crossDomain && (e.type = "GET", e.global =! 1)}), x.ajaxTransport ("script", fonction (e) {if (e.crossDomain) {var n, r = a.head || x ("head") [0] || a.documentElement; return {send: function (t, i) {n = a.createElement ("script" "), n.async =! 0, e.scriptCharset && (n.charset = e.scriptCharset), n.src = e.url, n.onload = n.onreadystatechange = fonction (e, t) {(t || ! n.readyState || / Load | Complete / .test (n.readyState)) && (n.onload = n.onreadystatechange = null, n.parentNode && n.parentNode.removeChild (n), n = null, t || i (200, "success"))}}, r.insertBefore (n, r.firstChild)}, abort: function () {n && n.onload (t,! 0)}}}}); var Fn = [], Bn = / (=) \? (? = & | $) | \? \? /; x.ajaxSetup ({jsonp: "callback", jsonpCallback: function () {var e = Fn.pop () || x.expando + "_" + vn ++; renvoyer ce [e] =! 0, e}}), x. ajaxPrefilter ("json jsonp", fonction (n, r, i) {var o, a, s, l = n.jsonp! ==! 1 && (Bn.test (n.url)? "url": "chaîne" == typeof n.data &&! (n.contentType || ""). indexOf ("application / x-www-form-urlencoded") && Bn.test (n.data) && "data"); retourne l || " jsonp "=== n.dataTypes [0]? (o = n.jsonpCallback = x.isFunction (n.jsonpCallback)? n.jsonpCallback (): n.jsonpCallback, l? n [l] = n [l]. remplacez (Bn, "$ 1" + o): n.jsonp! ==! 1 && (n.url + = (bn.test (n.url)? "&": "?") + n.jsonp + "=" + o), n.converters ["script json"] = function () {return s || x.error (o + "n'a pas été appelé"), s [0]}, n.dataTypes [0] = "json", a = e [o],e [o] = fonction () {s = arguments}, toujours (fonction () {e [o] = a, n [o] && (n.jsonpCallback = r.jsonpCallback, Fn.push (o)) , s && x.isFunction (a) && a (s [0]), s = a = t}), "script"): t}); var Pn, Rn, Wn = 0, $ n = e.ActiveXObject && function () { var e; pour (e dans Pn) Pn [e] (t,! 0)}; fonction In () {try {retour new e.XMLHttpRequest} catch (t) {}} function zn () {try {retour new e.ActiveXObject ("Microsoft.XMLHTTP")} catch (t) {}} x.ajaxSettings.xhr = e.ActiveXObject? function () {return! this.isLocal && In () || zn ()}: In, Rn = x.ajaxSettings.xhr (), x.support.cors = !! Rn && "withCredentials" dans Rn, Rn = x.support.ajax = !! Rn, Rn && x.ajaxTransport (fonction (n) {if (! n.crossDomain || x.support.cors) {var r; retour {send: function (i, o) {var a, s, l = n.xhr (); if (n.nom_utilisateur? l.open (n.type, n.url, n.async, n.username, n.password): l.open (n.type, n.url, n.async), n.xhrFields) pour (s dans n.xhrFields) l [s] = n.xhrFields [s]; n.mimeType && l.overrideMimeType && l.overrideMimeType (n.mimeType), n.crossDomain || i ["X-Requested-With"] || (i ["X-Requested-With"] = "XMLHttpRequest"); essayer {pour (s dans i) l.setRequestHeader (s, i [s])} catch (u) {} l.send (n .hasContent && n.data || null), r = fonction (e, i) {var s, u, c, p; essayer {si (r && (i || 4 === l.readyState)) si (r = t , a && (l.onreadystatechange = x.noop, $ n && delete Pn [a]), i) 4! == l.readyState && l.abort (); sinon {p = {}, s = l.status, u = l. getAllResponseHeaders (), "string" == type of l.responseText && (p.text = l.responseText); try {c = l.statusText} capture (f) {c = ""} s ||! n.isLocal || n.crossDomain? 1223 === s && (s = 204): s = p.text? 200: 404}} capture (d) {i || o (-1, d)} p && o (s, c, p, u)}, n.async? 4 === l.readyState? setTimeout (r) :( a = ++ Wn, $ n &&(Pn || (Pn = {}, x (e) .unload ($ n)), Pn [a] = r), l.onreadystatechange = r): r ()}, annuler: function () {r && r ( t,! 0)}}}}); var Xn, Un, Vn = / ^ (?: basculer | afficher | masquer) $ /, Yn = RegExp ("^ (?: ([+ -]) = |) ("+ w +") ([az%] *) $ "," i "), Jn = / queueHooks $ /, Gn = [nr], Qn = {" * ": [fonction (e, t) {var n = this.createTween (e, t), r = n.cur (), i = Yn.exec (t), o = i && i [3] || (x.cssNumber [e]? "": "px" ), a = (x.cssNumber [e] || "px"! == o && + r) && Yn.exec (x.css (n.elem, e)), s = 1, l = 20; si (a && a [3]! == o) {o = o || a [3], i = i || [], a = + r || 1; est-ce que s = s || ".5", a / = s , x.style (n.elem, e, a + o); while (s! == (s = n.cur () / r) && 1! == s && - l)} renvoie i && (a = n. début = + a || + r || 0, n.unité = o, n.end = i [1]? a + (i [1] +1) * i [2]: + i [2]), n }]}; fonction Kn () {return setTimeout (fonction () {Xn = t}), Xn = x.now ()} fonction Zn (e, t, n) {varr, i = (Qn [t] || []). concat (Qn ["*"]),o = 0, a = i.length; pour (; a> o; o ++) si (r = i [o] .call (n, t, e)) renvoie r} function er (e, t, n) { var r, i, o = 0, a = Longueur, s = x.Deferred (). always (function () {delete l.elem}), l = function () {if (i) return! 1; var t = Xn || Kn (), n = Math.max (0, u.startTime + u.duration-t), r = n / u.duration || 0, o = 1-r, a = 0, l = u.tweens.length; pour (; l> a; a ++) u.tweens [a] .run (o); renvoyer s.notifyWith (e, [u, o, n]), 1> o && l? n : (s.resolveWith (e, [u]) ,! 1)}, u = s.promise ({elem: e, props: x.extend ({}, t), opte: x.extend (! 0, {specialEasing: {}}, n), OriginalProperties: t, originalOptions: n, startTime: Xn || Kn (), durée: n.duration, tweens: [], createTween: function (t, n) {var r = x.Tween (e, u.opts, t, n, u.opts.specialEasing [t] || u.opts.easing); retourne u.tweens.push (r), stop: function (t) {var n = 0, r = t? u.tweens.length: 0; si (i) renvoie ceci; pour (i =! 0; r> n; n ++) u.tweens [n] .run (1); retourne t? s.resolveWith (e, [u, t]): s.rejectWith (e, [u, t]), this}}), c = u.props;for (tr (c, u.opts.specialEasing); a> o; o ++) if (r = Gn [o] .call (u, e, c, u.opts)) renvoie r; renvoie x.map (c , Zn, u), x.isFunction (u.opts.start) && u.opts.start.call (e, u), x.fx.timer (x.extend (l, {elem: e, anim: u, file d'attente: u.opts.queue})), u.progress (u.opts.progress) .done (u.opts.done, u.opts.complete) .fail (u.opts.fail). toujours (u. opts.always)} function tr (e, t) {var n, r, i, o, a; pour (n dans e) si (r = x.camelCase (n), i = t [r], o = e [n], x.isArray (o) && (i = o [1], o = e [n] = o [0]), n! == r && (e [r] = o, supprimez e [n ]), a = x.cssHooks [r], a && "expand" dans a) {o = a.expand (o), supprimez e [r]; pour (n dans o) n dans e || (e [n ] = o [n], t [n] = i)} sinon t [r] = i} x.Animation = x.extend (er, {tweener: function (e, t) {x.isFunction (e)? (t = e, e = ["*"]): e = e.split (""); var n, r = 0, i = e.longueur; pour (; i> r; r ++) n = e [ r], Qn [n] = Qn [n] || [], Qn [n] .unshift (t)}, préfiltre: fonction (e, t) {t? Gn.unshift (e): Gn.push ( e)}});fonction nr (e, t, n) {var r, i, o, a, s, l, u = ceci, c = {}, p = e.style, f = e.nodeType && nn (e), d = x ._data (e, "fxshow"); n.queue || (s = x._queueHooks (e, "fx"), null == s.unqueued && (s.unqueued = 0, l = s.empty.fire, s.empty.fire = function () {s.unqueued || l ()}), s.unqueued ++, u.always (function () {u.always (function () {s.unqueued -, x.queue (e, "fx"). length || s.empty.fire ()})}), 1 === e.nodeType && ("hauteur" dans t || "largeur" ​​dans t) && (n.overflow = [p.overflow, p.overflowX, p.overflowY], "inline" === x.css (e, "display") && "none" === x.css (e, "float") && ( x.support.inlineBlockNeedsLayout && "inline"! == ln (e.nodeName)? p.zoom = 1: p.display = "inline-block")), n.overflow && (p.overflow = "hidden", x. support.shrinkWrapBlocks || toujours (fonction () {p.overflow = n.overflow [0], p.overflowX = n.overflow [1], p.overflowY = n.overflow [2]})); pour (r dans t) si (i = t [r], Vn.exec (i )) {if (efface t [r], o = o || "bascule" === i, i === (f? "masquer": "montrer")) continuer; c [r] = d && d [r ] || x.style (e, r)} if (! x.isEmptyObject (c)) {d? "hidden" dans d && (f = d.hidden): d = x._data (e, "fxshow", {}), o && (d.hidden =! f), f? x (e) .show (): u.done (fonction () {x (e) .hide ()}), u.done (fonction ( ) {var t; x._removeData (e, "fxshow"); pour (t dans c) x.style (e, t, c [t])}) pour pour (r dans c) a = Zn (f? d [r]: 0, r, u), r dans d || (d [r] = a.start, f && (a.end = a.start, a.start = "width" === r || "hauteur" === r? 1: 0))}} fonction rr (e, t, n, r, i) {retourne un nouveau rr.prototype.init (e, t, n, r, i)} x. Tween = rr, rr.prototype = {constructeur: rr, init: fonction (e, t, n, r, i, o) {this.elem = e, this.prop = n, this.easing = i || " swing ", this.options = t, this.start = ceci.maintenant = this.cur (), this.end = r, this.unit = o || (x.cssNumber [n]? "": "px")}, cur: function () {var e = rr.propHooks [this.prop]; return e && e.get? e.get (this): rr.propHooks._default.get (this)}, exécutez: function (e) {var t, n = rr.propHooks [this.prop] ; return this.pos = t = this.options.duration? x.easing [this.easing] (e, this.options.duration * e, 0,1, this.options.duration): e, this.now = (this.end-this.start) * t + this.start, this.options.step && this.options.step.call (this.elem, this.now, this), n && n.set? n.set (ceci): rr.propHooks._default.set (this), this}}, rr.prototype.init.prototype = rr.prototype, rr.propHooks = {_ défaut: {get: fonction (e) {var t; retour null == e .elem [e.prop] || e.elem.style && null! = e.elem.style [e.prop]? (t = x.css (e.elem, e.prop, ""), t && "auto" ! == t? t: 0): e.elem [e.prop]}, ensemble: fonction (e) {x.fx.step [e.prop]? x.fx.step [e.prop] (e): e.elem.style && (null! = e.elem.style [x.cssProps [e.prop]] || x.cssHooks [e.prop])? x.style (e.elem, e.prop, e.now + e.unit): e.elem [e.prop] = e.now}}}, rr.propHooks.scrollTop = rr.propHooks.scrollLeft = {set: function (e) {e .elem.nodeType && e.elem.parentNode && (e.elem [e.prop] = e.now)}}, x.each (["bascule", "show", "masquer"], fonction (e, t) { var n = x.fn [t]; x.fn [t] = fonction (e, r, i) {retour null == e || "boolean" == type of e? n.apply (this, arguments): this.animate (ir (t,! 0), e, r, i)}}), x.fn.extend ({fadeTo: function (e, t, n, r) {retourne this.filter (nn). css ("opacité", 0) .show (). end (). animate ({opacité: t}, e, n, r)}, animée: fonction (e, t, n, r) {var i = x .isEmptyObject (e), o = x.speed (t, n, r), a = fonction () {var t = er (this, x.extend ({}, e), o); (i || x ._data (this, "finish")) && t.stop (! 0)}; renvoyer a.finish = a, i || o.queue ===! 1? this.each (a):this.queue (o.queue, a)}, arrête: fonction (e, n, r) {var i = fonction (e) {var t = e.stop; supprime e.stop, t (r)}; retour "chaîne"! = typede e && (r = n, n = e, e = t), n && e! ==! 1 && this.queue (e || "fx", []), this.each (fonction () {var t =! 0, n = null! = e && e + "queueHooks", o = x.timers, a = x._data (this); if (n) a [n] && a [n] .stop && i (a [n]) ; else pour (n dans a) a [n] && a [n] .stop && Jn.test (n) && i (a [n]); pour (n = o.length; n -;) o [n] .elem ! == this || null! = e && o [n] .queue! == e || (o [n] .anim.stop (r), t =! 1, o.splice (n, 1)); t ||! r) && x.dequeue (this, e)})}, finition: function (e) {return e! ==! 1 && (e = e || "fx"), this.each (function () {var t, n = x._data (this), r = n [e + "file d'attente"], i = n [e + "files d'attente"], o = x.timers, a = r? r.length: 0; pour (n.finish =! 0, x.queue (this, e, []), i && i.stop && i.stop.call (this,! 0), t = o.longueur; t -;) o [t] .elem === ceci && o [t] .queue === e && (o [t] .anim.stop (! 0), o.splice (t, 1)); pour (t = 0; a> t; t ++) r [t] && r [t] .finish && r [t] .finish.call (this); supprimer n.finish})}}); fonction ir (e, t) {var n, r = {hauteur: e}, i = 0; pour (t = t? 1: 0; 4> i; i + = 2-t) n = Zt [i], r ["marge" + n ] = r ["padding" + n] = e; renvoyer t && (r.opacité = r.width = e), r} x.each ({slideDown: ir ("show"), slideUp: ir ("masquer" ), slideToggle: ir ("bascule"), fadeIn: {opacité: "show"}, fadeOut: {opacité: "masquer"}, fadeToggle: {opacité: "bascule}}, fonction (e, t) {x .fn [e] = fonction (e, n, r) {retourne this.animate (t, e, n, r)}}), x.speed = fonction (e, t, n) {var r = e && " objet "== typeof e? x.extend ({}, e): {complete: n ||! n && t || x.isFunction (e) && e, duration: e, easing: n && t || t &&! x.isFunction ( t) && t};return r.duration = x.fx.off? 0: "nombre" == typeder.duration? r.duration: r.duration en x.fx.speeds? x.fx.speeds [r.duration]: x. fx.speeds._default, (null == r.queue || r.queue ===! 0) && (r.queue = "fx"), r.old = r.complete, r.complete = function () {x.isFunction (r.old) && r.old.call (this), r.queue && x.dequeue (this, r.queue)}, r}, x.easing = {linear: function (e) {return e} , swing: fonction (e) {return.5-Math.cos (e * Math.PI) / 2}}, x.timers = [], x.fx = rr.prototype.init, x.fx.tick = function () {var e, n = x.timers, r = 0; pour (Xn = x.now (); n.longueur> r; r ++) e = n [r], e () || n [r ]! == e || n.splice (r -, 1); n.longueur || x.fx.stop (), Xn = t}, x.fx.timer = fonction (e) {e () && x.timers.push (e) && x.fx.start ()}, x.fx.interval = 13, x.fx.start = fonction () {Un || (Un = setInterval (x.fx.tick, x .fx.interval))}, x.fx.stop = function () {clearInterval (Un), Un = null}, x.fx.speeds = {lent: 600, rapide: 200, _default:400}, x.fx.step = {}, x.expr && x.expr.filters && (x.expr.filters.animated = fonction (e) {retour x.grep (x.timers, fonction (t) {retour e = == t.elem}). length}), x.fn.offset = fonction (e) {if (arguments.length) renvoie e === t? ceci: ceci.each (fonction (t) {x.offset .setOffset (this, e, t)}; var n, r, o = {haut: 0, gauche: 0}, a = ceci [0], s = a &&a.ownerDocument; if (s) retourne n = s .documentElement, x.contains (n, a)? (type of a.getBoundingClientRect! == i && (o = a.getBoundingClientRect ()), r = ou (s), {top: o.top + (r.pageYOffset || n.scrollTop) - (n.clientTop || 0), à gauche: o.left + (r.pageXOffset || n.scrollLeft) - (n.clientLeft || 0)}): o}, x.offset = {setOffset : fonction (e, t, n) {var r = x.css (e, "position"); "statique" === r && (e.style.position = "relative"); var i = x (e) , o = i.offset (), a = x.css (e, "haut"), s = x.css (e, "gauche"), l = ("absolu" === r || "corrigé"=== r) && x.inArray ("auto", [a, s])> - 1, u = {}, c = {}, p, f; l? (c = i.position (), p = c.top, f = c.left) :( p = parseFloat (a) || 0, f = parseFloat (s) || 0), x.isFunction (t) && (t = t.call (e, n , o)), null! = t.top && (u.top = t.top-o.top + p), null! = t.left && (u.left = t.left-o.left + f), " using "in t? t.using.call (e, u): i.css (u)}}, x.fn.extend ({position: fonction () {if (this [0]) {var e, t , n = {top: 0, left: 0}, r = this [0]; retourne "fixed" === x.css (r, "position")? t = r.get.BoundingClientRect () :( e = this .offsetParent (), t = this.offset (), x.nodeName (e [0], "html") || (n = e.offset ()), n.top + = x.css (e [0] , "borderTopWidth",! 0), n.left + = x.css (e [0], "borderLeftWidth",! 0)), {top: t.top-n.top-x.css (r, "marginTop ",! 0), à gauche: t.left-n.left-x.css (r," marginLeft ",! 0)}}}, offsetParent: function () {retour this.map (function () {var e = ceci.offsetParent || s; while (e &&! x.nodeName (e, "html") && "statique" === x.css (e, "position")) e = e.offsetParent; retour e || s}) }}), x.each ({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, fonction (e, n) {var r = / Y / .test (n); x.fn [e] = fonction ( i) {retourne x.access (this, fonction (e, i, o) {var a = ou (e); retourne o === t? a? n dans a? a [n]: a.document.documentElement [i]: e [i] :( a? a.scrollTo (r? x (a) .scrollLeft (): o, r? o: x (a) .scrollTop ()): e [i] = o, t)}, e, i, arguments.length, null)}}); fonction ou (e) {retour x.isWindow (e)? e: 9 === e.nodeType? e.defaultView || e.parentWindow :! 1} x.each ({Hauteur: "hauteur", Largeur: "largeur"}, fonction (e, n) {x.each ({padding: "inner" + e, contenu: n, "": " outer "+ e}, fonction (r, i) {x.fn [i] = fonction (i, o) {var a = arguments.length && (r ||" booléen "! = typede i), s = r | | (i ===! 0 || o ===!0? "Margin": "border"); retourne x.access (this, fonction (n, r, i) {var o; retourne x.isWindow (n)? N.document.documentElement ["client" + e] : 9 === n.nodeType? (O = n.documentElement, Math.max (n.body ["scroll" + e], o ["scroll" + e], n.body ["offset" + e] , o ["offset" + e], o ["client" + e])): i === t? x.css (n, r, s): x.style (n, r, i, s) }, n, a? i: t, a, null)}})}), x.fn.size = function () {return this.length}, x.fn.andSelf = x.fn.addBack, "objet "== typeof module && module &&" objet "== typeof module.exports? module.exports = x: (e.jQuery = e. $ = x," fonction "== typeof définir && define.amd && define (" jquery ", [], fonction () {return x}))}) (fenêtre);client "+ e]: 9 === n.nodeType? (o = n.documentElement, Math.max (n.body [" scroll "+ e], o [" scroll "+ e], n.body [" offset "+ e], o [" offset "+ e], o [" client "+ e])): i === t? x.css (n, r, s): x.style (n, r , i, s)}, n, a, i, t, a, null)}}}}, x.fn.size = function () {retour this.length}, x.fn.andSelf = x.fn .addBack, "objet" == typeof module && module && "objet" == typeof module.exports? module.exports = x: (e.jQuery = e. $ = x, "fonction" == typede définir && define.amd && define ("jquery" , [], function () {return x}))}) (window);client "+ e]: 9 === n.nodeType? (o = n.documentElement, Math.max (n.body [" scroll "+ e], o [" scroll "+ e], n.body [" offset "+ e], o [" offset "+ e], o [" client "+ e])): i === t? x.css (n, r, s): x.style (n, r , i, s)}, n, a, i, t, a, null)}}}}, x.fn.size = function () {retour this.length}, x.fn.andSelf = x.fn .addBack, "objet" == typeof module && module && "objet" == typeof module.exports? module.exports = x: (e.jQuery = e. $ = x, "fonction" == typede définir && define.amd && define ("jquery" , [], function () {return x}))}) (window);longueur}, x.fn.andSelf = x.fn.addBack, "objet" == typeof module && module && "objet" == typeof module.exports? module.exports = x: (e.jQuery = e. $ = x, " function "== typeof define && define.amd && define (" jquery ", [], function () {return x}))}) (fenêtre);longueur}, x.fn.andSelf = x.fn.addBack, "objet" == typeof module && module && "objet" == typeof module.exports? module.exports = x: (e.jQuery = e. $ = x, " function "== typeof define && define.amd && define (" jquery ", [], function () {return x}))}) (fenêtre);
