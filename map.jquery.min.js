/ *! jQuery v2.0.0 | (c) 2005, 2013 jQuery Foundation, Inc. | jquery.org/license
// @ sourceMappingURL = jquery.min.map
* /
(fonction (e, indéfinie) {var t, n, r = type indéfini, i = emplacement.e, o = e.document, s = o objet.documentElement, a = e.jQuery, u = e. $, l = {}, c = [], f = "2.0.0", p = c.concat, h = c.push, d = c.slice, g = c.indexOf, m = l.toString, y = l. hasOwnProperty, v = f.trim, x = fonction (e, n) {retourne un nouveau x.fn.init (e, n, t)}, b = / [+ -]? (?: \ d * \. | ) \ d + (?: [eE] [+ -]? \ d + |) /. source, w = / \ S + / g, T = / ^ (?: (<[\ w \ W] +>) [^ >] * | # ([\ w -] *)) $ /, C = / ^ <(\ w +) \ s * \ /?> (?: <\ / \ 1> |) $ /, k = / ^ -ms - /, N = / - ([\ da-z]) / gi, E = fonction (e, t) {retour t.toUpperCase ()}, S = fonction () {o.removeEventListener ("DOMContentLoaded ", S,! 1), e.removeEventListener (" load ", S,! 1), x.ready ()}; x.fn = x.prototype = {jquery: f, constructeur: x, init: fonction ( e, t, n) {var r, i; if (! e) renvoie ceci; if ("chaîne" == typeof e) {if (r = "<" === e.charAt (0) && "> "=== e.charAt (e.length-1) && e.length> = 3? [null, e, null]: T.exec (e),! r ||! r [1] && t) retourne! t || t.jquery? (t || n) .find (e): this.constructor (t) .find (e); if (r [1]) {if (t = t instance de x? t [0]: t, x.merge (this, x.parseHTML (r [1], t && t.nodeType? t.ownerDocument || t: o, ! 0)), C.test (r [1]) && x.isPlainObject (t)) pour (r dans t) x.isFunction (this [r])? This [r] (t [r]): this. attr (r, t [r]); renvoyer ceci} renvoyer i = o.getElementById (r [2]), i && i.parentNode && (this.length = 1, this [0] = i), this.context = o, this.selector = e, this} retourne e.nodeType? (this.context = this [0] = e, this.length = 1, this): x.isFunction (e)? n.ready (e) :( e .selector! == undefined && (this.selector = e.selector, this.context = e.context), x.makeArray (e, this))}, sélecteur: "", longueur: 0, toArray: function () { return d.call (this)}, get: function (e) {return null == e? this.toArray (): 0> e? this [this.length + e]: this [e]}, pushStack: function (e) {var t = x.merge (this.constructor (), e);return t.prevObject = this, t.context = this.context, t}, each: function (e, t) {return x.each (this, e, t)}, prêt: function (e) {return x. ready.promise (). done (e), this}, slice: function () {renvoie this.pushStack (d.apply (this, arguments))}, premier: function () {renvoie this.eq (0)} , last: function () {return this.eq (-1)}, eq: function (e) {var t = this.length, n = + e + (0> e? t: 0); renvoie this.pushStack ( n> = 0 && t> n? [this [n]]: [])}, map: fonction (e) {retourne ceci.pushStack (x.map (this, fonction (t, n) {retourne e.call (t , n, t)}))}, fin: function () {return this.prevObject || this.constructor (null)}, push: h, tri: []. sort, splice: []. splice}, x .fn.init.prototype = x.fn, x.extend = x.fn.extend = function () {var, t, n, r, i, o, s = arguments [0] || {}, a = 1, u = arguments.length, l =! 1; pour ("booléen" == typeof s && (l = s, s = arguments [1] || {}, a = 2), "objet" == typeof s || x.isFunction (s) || (s = {}), u === a && (s = ceci,--a); u> a; a ++) si (null! = (e = arguments [a])) pour (t dans e) n = s [t], r = e [t], s! == r && (l && r && (x.isPlainObject (r) || (i = x.isArray (r)))? (i? (i =! 1, o = n && x.isArray (n)? n: []): o = n && x .isPlainObject (n)? n: {}, s [t] = x.extend (l, o, r)): r! == undefined && (s [t] = r)); renvoie s}, x.extend ({expando: "jQuery" + (f + Math.random ()). replace (/ \ D / g, ""), noConflict: function (t) {retourne e. $ === x && (e. $ = u), t && e.jQuery === x && (e.jQuery = a), x}, isReady:! 1, readyWait: 1, holdReady: function (e) {e? x.readyWait ++: x.ready (! 0) }, prêt: fonction (e) {(e ===! 0? - x.readyWait: x.isReady) || (x.isReady =! 0, e! ==! 0 && - x.readyWait> 0 || (n.resolveWith (o, [x]), x.fn.trigger && x (o) .trigger ("ready"). off ("ready")))}, isFunction: function (e) {return "function "=== x.type (e)}, isArray: Array.isArray, isWindow:function (e) {return null! = e && e === e.window}, isNumeric: function (e) {return! isNaN (parseFloat (e)) && isFinite (e)}, tapez: function (e) {return null = = e? e + "": "objet" == typeof e || "fonction" == typeof e? l [m.call (e)] || "objet": typeof e}, isPlainObject: fonction (e) { if ("objet"! == x.type (e) || e.nodeType || x.isWindow (e)) renvoie! 1; essayez {if (e.constructor &&! y.call (e.constructor.prototype, "isPrototypeOf")) return! 1} catch (t) {return! 1} return! 0}, isEmptyObject: function (e) {var t; pour (t dans e) return! 1; return! 0}, error: fonction (e) {erreur de jeton (e)}, parseHTML: fonction (e, t, n) {si (! e || "chaîne"! = typede e) retourne null; "booléen" == typede t && (n = t, t =! 1), t = t || o; var r = C.exec (e), i =! n && []; retourne r? [t.createElement (r [1])] :( r = x.buildFragment ([e], t, i), i && x (i) .remove (), x.merge ([], r.childNodes))}}, parseJSON: JSON.parse, parseXML: fonction (e) {var t, n; si (! e || "chaîne"! = typeof e) retourne null; try {n = nouveau DOMParser, t = n .parseFromString (e, "text / xml")} catch (r) {t = non défini} return (! t || t.getElementsByTagName ("analyseur"). length) && x.error ("XML non valide:" + e) , t}, noop: fonction () {}, globalEval: fonction (e) {var t, n = eval; e = x.trim (e), e && (1 === e.indexOf ("use strict") ? (t = o.createElement ("script"), t.text = e, o.head.appendChild (t) .parentNode.removeChild (t)): n (e))}, camelCase: fonction (e) { renvoyer e.replace (k, "ms -"). remplacer (N, E)}, NomNoeud: function (e, t) {retourne e.nodeName && e.nodeName.toLowerCase () === t.toLowerCase ()}, chacun: fonction (e, t, n) {varr, i = 0, o = e.longueur, s = j (e); si (n) {si (s) {pour (; o> i; i ++) si (r = t.apply (e [i], n), r ===! 1) rompt} sinon pour (i dans e) if (r = t.apply (e [i], n), r = ==!1) casse} autre si (s) {pour (; o> i; i ++) si (r = appel.c (e [i], i, e [i]), r ===! 1) pause} autre pour (i dans e) si (r = t.call (e [i], i, e [i]), r ===! 1) coupure; retour e}, trim: fonction (e) {retour null = = e? "": v.call (e)}, makeArray: fonction (e, t) {var n = t || []; renvoie null! = e && (j (Object (e))?? x.merge ( n, "chaîne" == typede e? [e]: e): h.call (n, e)), n}, inArray: fonction (e, t, n) {retour null == t? -1: g.call (t, e, n)}, fusion: fonction (e, t) {var n = longueur t, r = longueur e, i = 0; if ("nombre" == type de n) pour ( ; n> i; i ++) e [r ++] = t [i]; sinon tandis que (t [i]! == non défini) e [r ++] = t [i ++]; retourne e.length = r, e}, grep : fonction (e, t, n) {var r, i = [], o = 0, s = e.longueur; pour (n = !! n; s> o; o ++) r = !! t (e [ o], o), n! == r && i.push (e [o]); retour i}, carte: fonction (e, t, n) {varr, i = 0, o = e.longueur, s = j (e), a = []; si (s) pour (; o> i; i ++) r = t (e [i], i, n), null! = r && (a [longueur.a long] = r ); sinon pour (i dans e) r = t (e [i], i, n), null! = r && (a [a.longueur] = r); retourne p.apply ([], a)}, guid: 1, proxy: fonction (e, t) {var n, r, i; retourne "chaîne" == typede t && (n = e [t], t = e, e = n), x.isFonction (e)? (r = d.call (arguments, 2), i = fonction () {retourne e.apply (t || this, r. concat (d.call (arguments)))}, i.guid = e.guid = e.guid || x.guid ++, i): non défini}, accès: fonction (e, t, n, r, i, o) , s) {var a = 0, u = longueur e, l = null == n; si ("objet" === x.type (n)) {i =! 0; pour (a dans n) x .access (e, t, a, n [a],! 0, o, s)} sinon si (r! == indéfini && (i =! 0, x.isFunction (r) || (s =! 0) , l && (s? (t.call (e, r), t = null) :( l = t, t = fonction (e, t, n) {retourne l.call (x (e), n)}) ), t)) pour (; u> a; a ++) t (e [a], n, s? r: r.call (e [a], a, t (e [a], n))); return i? e: l? t.call (e): u? t (e [0], n): o}, maintenant: Date.now, échange: fonction (e, t, n, r) {var i , o, s = {}; pour (o in t) s [o] = e.style [o], e.style [o] = t [o]; i = n.apply (e, r || [ ]); pour (o in t) e.style [o] = s [o]; retourne i}}), x.ready.promise = fonction (t) {retourne n || (n = x.Deferred (), "complete" === o.readyState? SetTimeout (x.ready) :( o.addEventListener ("DOMContentLoaded", S,! 1), e.addEventListener ("charge", S,! 1)) ), n.promise (t)}, x.each ("Boolean Number String Function Tableau Date RegExp Object Error" .split (""), fonction (e, t) {l ["[objet" + t + "]" ] = t.toLowerCase ()}); fonction j (e) {var t = e.longueur, n = x.type (e); retourne x.isWindow (e)?! 1: 1 === e.nodeType && t ?! 0: "tableau" === n || "fonction"! == n && (0 === t || "numéro" == typede t && t> 0 && t-1 dans e)} t = x (o), fonction (e, indéfinie) {var t, n, r, i, o, s, a, u, l, c, f, p, h, d, g, m, y = "grésillement" + - nouvelle date, v = e.document, b = {}, w = 0, T = 0, C = ot (), k = ot (), N = ot (), E =! 1, S = fonction () {retour 0 }, j = typede non défini, D = 1 << 31, A = [], L = A.pop, q = A.push, H = A.push, O = A.slice, F = A.indexOf || fonction (e) {var t = 0,n = this.length; for (; n> t; t ++) si (this [t] === e) renvoie t; retour-1}, P = "coché | sélectionné | asynchrone | autofocus | lecture automatique | commandes | différer | disabled | hidden | ismap | loop | multiple | open | readonly | required | scoped ", R =" [\\ x20 \\ t \\ r \\ n \\ f] ", M =" (?: \\ \\. | [\\ w-] | [^ \\ x00 - \\ xa0]) + ", W = M.replace (" w "," w # "), $ =" \\ ["+ R + "* (" + M + ")" + R + "* (?: ([* ^ $ |! ~]? =)" + R + "* (?: (['\"]) ((?: \\\ \. | [[^ \\\\]] *?) \\ 3 | ("+ W +") |) |) "+ R +" * \\] ", B =" :( "" + M + ") (? : \\ ((('' "") ((?: \\\\. | [^ \\\\]] *?) \\ 3 | (?: \\\\. | [^ \ \\\ () [\\]] | "+ $. replace (3,8) +") *) |. *) \\) |) ", I = RegExp (" ^ "+ R +" + | (?: ^ | [^ \\\\]) (?: \\\\.) *) "+ R +" + $ "," g "), z = RegExp (" ^ "+ R +" *, " + R + "*"), _ = RegExp ("^" + R + "* ([> + ~] |"+ R + ")" + R + "*"), X = RegExp (R + "* [+ ~]"), U = RegExp ("=" + R + "* ([^ \\] '\"] *) " + R + "* \\]", "g"), Y = RegExp (B), V = RegExp ("^" + W + "$"), G = {ID: RegExp ("^ # (" + M + " ) "), CLASS: RegExp (" ^ \\. ("+ M +") "), TAG: RegExp (" ^ ("+ M.replace (" w "," w * ") +") "), ATTR: RegExp ("^" + $), PSEUDO: RegExp ("^" + B), ENFANT: RegExp ("^ :( seulement | premier | dernier | nième | nième-dernier) - (enfant | de type) (?: \\ ("+ R +" * (pair | impair) (([+ -] |) (\\ d *) n |) "+ R +" * (?: ([+ -] |) "+ R + "* (\\ d +) |))" + R + "* \\) |)", "i"), "booléen": RegExp ("^ (?:" + P + ") $", "i" ), needsContext: RegExp ("^" + R + "* [> + ~] |: (pair | impair | eq | gt | lt | nth | premier | dernier) (?: \\ (" + R + "* (( ?:- \\ d)? \\ d *) "+ R +" * \\) |) (? = [^ -] | $) "," i ")}, J = / ^ [^ {] + \ { \ s * \ [natif \ w /, Q = / ^ (?: # ([\ w -] +) | (\ w +) | \. ([\ w -] +)) $ /, K = / ^ (?: input | select | textarea | button) $ / i, Z = / ^ h \ d $ / i, et = / '| \\ / g, tt = / \\ ([\ da-fA-F] {1,6} [\ x20 \ t \ r \ n \ f]? |.) / G, nt = fonction (e, t) {var n = "0x" + t-65536; retourne n! == n ? t: 0> n? String.fromCharCode (n + 65536): String.fromCharCode (55296 | n >> 10,56320 | 1023 & n)}; try {H.apply (A = O.call (v.childNodes), v.childNodes), A [v.childNodes.length] .nodeType} catch (rt) {H = {appliquer: A.length? fonction (e, t) {q.apply (e, O.call (t)) }: fonction (e, t) {var n = longueur e, r = 0; tandis que (e [n ++] = t [r ++]); e. longueur = n-1}}} la fonction (e) {retour J.test (e + "")} function ot () {var e, t = []; retourne e = fonction (n, i) {retourne t.push (n + = "")>> r.cacheLength && delete e [t. shift ()], e [n] = i}} fonction st (e) {retour e e [y] =! 0, e} fonction en (e) {var t = c.createElement ("essaye {return !! e (t)} catch (n) {return! 1} enfin {t.parentNode && t.parentNode.removeChild (t), t = null}} fonction ut (e, t, n, r) {var i, o, s, a, u, f, d, g, x, w; if ((t? t.ownerDocument || t: v)! == c && l (t), t = t | | c, n = n || [],! e || "chaîne"! = type e) retourne n; si (1! == (a = t.nodeType) && 9! == a) retourne []; si (p &&! r) {si (i = Q.exec (e)) si (s = i [1]) {si (9 === a) {si (o = t.getElementById (s) ,! o | |! o.parentNode) retourne n; si (o.id === s) retourne n.push (o), n} autre si (t.ownerDocument && (o = t.ownerDocument.getElementById (s)) && m (t , o) && o.id === s) retourne n.push (o), n} autre {if (i [2]) retourne H.apply (n, t.getElementsByTagName (e)), n; if (( s = i [3]) && b.getElementsByClassName && t.getElementsByClassName) renvoie H.apply (n, t.getElementsByClassName (s)), n} if (b.qsa && (! h ||! h.test (e))) { si (g = d = y, x = t, w = 9 === a && e, 1 === a && "objet"! == t.nodeName.toLowerCase ()) {f = gt (e), (d = t.getAttribute ("id"))? g = d.replace (et, "\\ $ &"): t.setAttribute ("id" , g), g = "[id = '" + g + "']", u = f.longueur; tandis que (u -) f [u] = g + mt (f [u]); x = X. test (e) && t.parentNode || t, w = f.join (",")} if (w) try {return H.apply (n, x.querySelectorAll (w)), n} catch (T) { } finally {d || t.removeAttribute ("id")}}} retourne kt (e.replace (I, "$ 1"), t, n, r)} o = ut.isXML = fonction (e) {var t = e && (e.ownerDocument || e) .documentElement; renvoie t? "HTML"! == t.nodeName:! 1}, l = ut.setDocument = fonction (e) {var t = e? e.ownerDocument || e: v; retourne t! == c && 9 === t.nodeType && t.documentElement? (c = t, f = t.documentElement, p =! o (t), b.getElementsByTagName = à (fonction (e) {return e.appendChild (t.createComment ("")),! e. getElementsByTagName ("*"). length}), b.attributs = at (fonction (e) {return e.className = "i",! e.getAttribute ("className")}), b.getElementsByClassName = at (fonction (e) {return e.innerHTML = "<classe div = 'a'> </ div> <div class = 'a i'> </ div> ", e.firstChild.className =" i ", 2 === e.getElementsByClassName (" i "). length}) , b.sortDetached = at (function (e) {return 1 & e.compareDocumentPosition (c.createElement ("div"))}), b.getById = at (function (e) {return f.appendChild (e) .id = y,! t.getElementsByName ||! t.getElementsByName (y) .length}), b.getById? (r.find.ID = fonction (e, t) {if (typede t.getElementById! == j && p) { var n = t.getElementById (e); retourne n && n.parentNode? [n]: []}}, r.filter.ID = fonction (e) {var t = e.replace (tt, nt); fonction de retour ( e) {return e.getAttribute ("id") === t}}) :( r.find.ID = fonction (e, t) {if (typeof t.getElementById! == j && p) {var n = t.getElementById (e); retourne n? n.id === e || typede n.getAttributeNode! == j && n.getAttributeNode ("id"). value === e ? [n]: undefined: []}}, r.filter.ID = fonction (e) {var t = e.replace (tt, nt); fonction de retour (e) {var n = type de e.getAttributeNode! = = j && e.getAttributeNode ("id"); renvoyer n && n.valeur === t}}), r.find.TAG = b.getElementsByTagName? fonction (e, t) {type de renvoi de t.getElementsByTagName! == j? t .getElementsByTagName (e): undefined}: fonction (e, t) {var n, r = [], i = 0, o = t.getElementsByTagName (e); if ("*" === e) {while ( n = o [i ++]) 1 === n.nodeType && r.push (n); renvoyer r} renvoyer o}, r.find.CLASS = b.getElementsByClassName && fonction (e, t) {renvoyer type of t.getElementsByClassName! == j && p? t.getElementsByClassName (e): indéfini}, d = [], h = [], (b.qsa = it (t.querySelectorAll)) && (at (fonction (e) {e.innerHTML = "<select> <option selected = ''> </ option> </ select>", e.querySelectorAll ("[sélectionné]"). length || h.push ("\\ [" + R + "* (?: valeur | "+ P +") "), e.querySelectorAll (": vérifié "). length || h.push (": vérifié ")}), à (fonction (e) {var t = c. createElement ("input"); t.setAttribute ("type", "caché"), e.appendChild (t) .setAttribute ("t", ""), e.querySelectorAll ("[t ^ = '']" ) .length && h.push ("[* ^ $] =" + R + "* (?: '' | \" \ ")"), e.querySelectorAll (": activé"). length || h.push (" : enabled ",": disabled "), e.querySelectorAll (" * ,: x "), h.push (",. *: ")}), (b.matchesSelector = it (g = f.webkitMatchesSelector | | f.mozMatchesSelector || f.oMatchesSelector || f.msMatchesSelector)) && at (fonction (e) {b.disconnectedMatch = g.call (e, "div"), g.call (e, "[s! = '']: x"), d.push ("! = ", B)}), h = h.length && RegExp (h.join (" | ")), d = d.length && RegExp (d.join (" | ")), m = it (f.contains) || f.compareDocumentPosition? function (e, t) {var n = 9 === e.nodeType? e.documentElement: e, r = t && t.parentNode; retourne e === r ||! (! r || 1! == r.nodeType ||! (n.contains? n.contains (r): e.compareDocumentPosition && 16 & e.compareDocumentPosition (r)))}: fonction (e, t) {if (t) tant que (t = t.parentNode ) si (t === e) retourne! 0; retourne! 1}, S = f.compareDocumentPosition? fonction (e, n) {si (e === n) retourne E =! 0,0; var r = n.compareDocumentPosition && e.compareDocumentPosition && e.compareDocumentPosition (n); return r? 1 & r ||! b.sortDetached && n.compareDocumentPosition (e) === r? e === t || m (v, e)? - 1:n === t || m (v, n)? 1: u? F.call (u, e) -F.call (u, n): 0: 4 & r? -1: 1: e.compareDocumentPosition? - 1: 1}: fonction (e, n) {varr, i = 0, o = e.parentNode, s = n.parentNode, a = [e], l = [n]; if (e === n ) retourne E =! 0,0; si (! o ||! s) retourne e === t? -1: n === t? 1: o? -1: s? 1: u? F.call (u, e) -F.call (u, n): 0; si (o === s) retourne lt (e, n); r = e; tant que (r = r.parentNode) a.unshift (r ); r = n; while (r = r.parentNode) l.unshift (r); tandis que (a [i] === l [i]) i ++; retourne i? lt (a [i], l [i ]): a [i] === v? -1: l [i] === v? 1: 0}, c): c}, ut.matches = fonction (e, t) {retourne ut (e , null, null, t)}, ut.matchesSelector = fonction (e, t) {if ((e.ownerDocument || e)! == c && l (e), t = t.replace (U, "= '$ 1 '] "),! (! b.matchesSelector ||! p || d && d.test (t) || h && h.test (t))) essayer {var n = g.call (e, t); if (n || b.disconnectedMatch || e.document && 11! == e.document.nodeType) retourne n} catch (r) {} retourne ut (t, c, null, [e]). length> 0}, ut.contains = fonction (e, t) {retourne (e.ownerDocument || e)! == c && l (e), m (e, t)}, ut.attr = fonction (e, t) {(e.ownerDocument || e)! == c && l (e); var n = r.attrHandle [t.toLowerCase ()], i = n && n (e, t,! p); retourne i === undefined? b.attributes ||! p? e.getAttribute (t) :( i = e .getAttributeNode (t)) && i.specified? i.value: null: i}, ut.error = function (e) {throw Erreur ("Erreur de syntaxe, expression non reconnue:" + e)}, ut.uniqueSort = function ( e) {var t, n = [], r = 0, i = 0; si (E =! b.detectDuplicates, u =! b.sortStable && e.slice (0), e.sort (S), E) { while (t = e [i ++]) t === e [i] && (r = n.push (i)); tandis que (r -) e.splice (n [r], 1)} retourne e} ; fonction lt (e, t) {var n = t && e, r = n && (~ t.sourceIndex || D) - (~ e.sourceIndex || D); if (r) renvoie r; if (n) while ( n = n.nextSibling) if (n === t) retour-1; retour e? 1: -1} fonction ct (e, t, n) {var r; retour n? non défini: (r = e.getAttributeNode (t)) && r.specified? r.value: e [t] ===! 0? t.toLowerCase (): null} fonction ft (e, t, n) {var r; retour n? undefined: r = e.getAttribute (t, "type" === t.toLowerCase ()? 1: 2)} fonction pt (e) {return function (t) {var n = t.nodeNom.toLowerCase (); return "input" === n && t.type === e}} function ht (e) {return function (t) { var n = t.nodeNome.toLowerCase (); return ("input" === n || "bouton" === n) && t.type === e}} function dt (e) {return st (fonction ( t) {retour t = + t, st (fonction (n, r) {var i, o = e ([], n.longueur, t), s = o.longueur; tandis que (s -) n [i = o [s]] && (n [i] =! (r [i] = n [i]))})}}} i = ut.getText = fonction (e) {var t, n = "", r = 0, o = e.nodeType; if (o) {if (1 === o || 9 === o || 11 === o) {if ("chaîne" == type de e.textContent) return e.textContent; for (e = e.firstChild; e; e = e.nextSibling) n + = i (e)} else if (3 === o || 4 === o) retourne e.nodeValue} else pour (; t = e [r]; r ++) n + = i (t); renvoyer n}, r = ut.selectors = {cacheLength: 50, createPseudo:st, match: G, attrHandle: {}, recherche: {}, relatif: {">": {dir: "parentNode", d'abord:! 0}, "": {dir: "parentNode"}, "+" : {dir: "previousSibling", premier:! 0}, "~": {dir: "previousSibling"}}, preFilter: {ATTR: function (e) {return e [1] = e [1] .replace ( tt, nt), e [3] = (e [4] || e [5] || ""). remplacer (tt, nt), "~ =" === e [2] && (e [3 ] = "" + e [3] + ""), e.slice (0,4)}, ENFANT: fonction (e) {retourne e [1] = e [1] .toLowerCase (), "nth" = == e [1]. slice (0,3)? (e [3] || ut.error (e [0]), e [4] = + (e [4]? e [5] + (e [6] || 1): 2 * ("pair" === e [3] || "impair" === e [3])), e [5] = + (e [7] + e [ 8] || "impair" === e [3])): e [3] && ut.error (e [0]), e}, PSEUDO: fonction (e) {var t, n =! E [5 ] && e [2]; renvoyer G.CHILD.test (e [0])? null: (e [4]? e [2] = e [4]: ​​n && Y.test (n) && (t = gt (n ,! 0)) && (t = n.indexOf (")", n.length-t) -n.length) && (e [0] = e [0] .lice (0, t), e [2] = n.slice (0, t)) , e.slice (0,3))}}, filter: {TAG: function (e) {var t = e.replace (tt, nt) .toLowerCase (); retourne "*" === e? fonction ( ) {return! 0}: function (e) {return e.nodeName && e.nodeName.toLowerCase () === t}}, CLASS: fonction (e) {var t = C [e + ""]; return t || (t = RegExp ("(^ |" + R + ")" + e + "(" + R + "| $)")) && C (e, fonction (e) {retourne t.test ("chaîne" == typede e .className && e.className || type of e.getAttribute! == j && e.getAttribute ("class") || "")})}, ATTR: fonction (e, t, n) {fonction de retour (r) {var i = ut.attr (r, e); return null == i? "! =" === t: t? (i + = "", "=" === t? i === n: "! =" === t? i! == n: "^ =" === t? n && 0 === i.indexOf (n): "* =" === t? n && i.indexOf (n)>-1: "$ =" === t? N && i.slice (-n.length) === n: "~ =" === t? ("" + I + "") .indexOf (n)> - 1: "| =" === t? I === n || i.slice (0, longueur n + 1) === n + "-" :! 1) :! 0}}, ENFANT: fonction (e, t, n, r, i) {var o = "nth"! == e.slice (0,3), s = "dernier"! == e.slice (-4), a = "de -type "=== t; return 1 === r && 0 === i? function (e) {return !! e.parentNode}: function (t, n, u) {var l, c, f, p, h, d, g = o! == s? "nextSibling": "previousSibling", m = t.parentNode, v = a && t.nodeNome.toLowerCase (), x =! u &&! a; if (m) {if ( o) {while (g) {f = t; while (f = f [g]) if (a? f.nodeName.toLowerCase () === v: 1 === f.nodeType) renvoie! 1; d = g = "seulement" === e &&! d && "nextSibling"} return! 0} if (d = [s? m.firstChild: m.lastChild], s && x) {c = m [y] || (m [ y] = {}), l = c [e] || [], h = l [0] === w && l [1], p = l [0] === w && l [2], f = h &&m.childNodes [h]; while (f = ++ h && f && f [g] || (p = h = 0) || d.pop ()) if (1 === f.nodeType && ++ p && f === t ) {c [e] = [w, h, p]; pause}} sinon if (x && (l = (t [y] || (t [y] = {})) [e]) && l [0] === w) p = l [1]; sinon while (f = ++ h && f && f [g] || (p = h = 0) || d.pop ()) if ((a? f.nodeNom.toLowerCase () === v: 1 === f.nodeType) && ++ p && (x && ((f [y] || (f [y] = {})) [e] = [w, p]), f === t)) pause; retourne p- = i, p === r || 0 === p% r && p / r> = 0}}}, PSEUDO: fonction (e, t) {var n, i = r.pseudos [e] || r.setFilters [e.toLowerCase ()] || ut.error ("pseudo non pris en charge:" + e); retourne i [y]? i (t): i.length> 1? (N = [e, e, "", t], r.setFilters.hasOwnProperty (e.toLowerCase ())? St (fonction (e, n) {varr, o = i (e, t), s = longueur, tandis que (s -) r = F.call (e, o [s]), e [r] =! (n [r] = o [s])}): fonction (e) {retourne i (e, 0, n)}): i}}, pseudos: {pas: st (fonction (e) {var t = [], n = [], r = s (e.replace (I, "1 $")); retourne r [y]? st (fonction (e, t, n, i) {varo, s = r (e, nul, i, []), a = e.longueur; tandis que (a-- ) (o = s [a]) && (e [a] =! (t [a] = o))}): fonction (e, i, o) {retourne t [0] = e, r (t, null, o, n),! n.pop ()}}), a: st (fonction (e) {return fonction (t) {return ut (e, t) .length> 0}}), contient: st (function (e) {return fonction (t) {return (t.textContent || t.innerText || i (t)). indexOf (e)> - 1}}), lang: st (fonction (e) { return V.test (e || "") || ut.error ("lang non pris en charge:" + e), e = e.replace (tt, nt) .toLowerCase (), function (t) {var n; do if (n = p? t.lang: t.getAttribute ("xml: lang") || t.getAttribute ("lang")) renvoie n = n.toLowerCase (), n === e || 0 == = n.indexOf (e + "-"); tandis que ((t = t.parentNode) && 1 === t.nodeType); return! 1}}), cible: fonction (t) {var n = e.location && e. location.hash; return n && n.slice (1) === t.id}, racine: fonction (e) {return e === f}, focus:function (e) {return e === c.activeElement && (! c.hasFocus || c.hasFocus ()) && !! (type e || e.href || ~ e.tabIndex)}, activé: fonction (e) {return e.disabled ===! 1}, désactivé: fonction (e) {return e.disabled ===! 0}, coché: fonction (e) {var t = e.nodeNome.toLowerCase () ; return "input" === t && !! e.checked || "option" === t && !! e.selected}, sélectionné: function (e) {retourne e.parentNode && e.parentNode.selectedIndex, e.selected = ==! 0}, vide: function (e) {pour (e = e.firstChild; e; e = e.nextossibling) if (e.nodeName> "@" || 3 === e.nodeType || 4 === e.nodeType) return! 1; return! 0}, parent: fonction (e) {return! r.pseudos.empty (e)}, en-tête: fonction (e) {return Z.test (e.nodeName )}, entrée: function (e) {return K.test (e.nodeName)}, bouton: function (e) {var t = e.nodeName.toLowerCase (); retourne "input" === t && "bouton" === e.type || "bouton"=== t}, text: function (e) {var t; retourner "input" === e.nodeName.toLowerCase () && "text" === e.type && (null == (t = e.getAttribute ("type")) || t.toLowerCase () === e.type)}, premier: dt (fonction () {return [0]}), dernier: dt (fonction (e, t) {return [ t-1]}), eq: dt (fonction (e, t, n) {return [0> n? n + t: n]}), même: dt (fonction (e, t) {var n = 0 ; pour (; t> n; n + = 2) e.push (n); retour e}), impair: dt (fonction (e, t) {var n = 1; pour (; t> n; n + = 2 ) e.push (n); retourne e}), lt: dt (fonction (e, t, n) {var r = 0> n? n + t: n; pour (; - r> = 0;) e.push (r); retour e}), gt: dt (fonction (e, t, n) {var r = 0> n? n + t: n; pour (; t> ++ r;) e. push (r); retourne e})}}; pour (t dans {radio:! 0, case à cocher:! 0, fichier:! 0, mot de passe:! 0, image:! 0}) r.pseudos [t] = pt (t); pour (t dans {submit:! 0, réinitialiser:! 0}) r.pseudos [t] = ht (t); fonction gt (e, t) {varn, i, o, s, a, u, l, c = k [e + ""]; si (c) retourne t? 0: c.slice (0); a = e, u = [], l = r.preFilter; tandis que (a) {(! n || (i = z.exec (a))) && (i && (a = a.slice (i [0] .length) || a), u.push (o = [])), n =! 1, (i = _. exec (a)) && (n = i.shift (), o.push ({valeur: n, type: i [0] .replace (I, "")}), a = a.slice (n.length) ); pour (s dans r.filter)! (i = G [s] .exec (a)) || l [s] &&! (i = l [s] (i)) || (n = i. shift (), o.push ({valeur: n, type: s, correspond à: i}), a = a.slice (n.length)); if (! n) break} retourne t? a.length: a ? ut.error (e): k (e, u). Slice (0)} fonction mt (e) {var t = 0, n = e.longueur, r = ""; pour (; n> t; t ++ ) r + = e [t] .value; retourne r} fonction yt (e, t, r) {var i = t.dir, o = r && "parentNode" === i, s = T ++; retourne t.first? fonction (t, n, r) {while (t = t [i]) if (1 === t.nodeType || o) retourne e (t, n, r)}: fonction (t, r, a) {var u, l, c, f = w + "" + s; si (a) {tant que (t = t [i]) si ((1 === t.nodeType || o) && e (t, r, a)) retourne! 0} sinon (t = t [i]) si (1 === t.nodeType || o) si (c = t [y] || (t [y] = {}), (l = c [i]) && l [0] === f) {if ((u = l [1]) ===!0 || u === n) renvoie u ===! 0} sinon (l = c [i] = [f], l [1] = e (t, r, a) || n, l [ 1] ===! 0) return! 0}} function vt (e) {return e.length> 1? Function (t, n, r) {var i = e.length; tant que (i -) if ( ! e [i] (t, n, r)) retourne! 1; retourne! 0}: e [0]} fonction xt (e, t, n, r, i) {var o, s = [], a = 0, u = longueur e, l = null! = T; pour (; u> a; a ++) (o = e [a]) && (! N || n (o, r, i)) && ( s.push (o), l && t.push (a)); retourne s} fonction bt (e, t, n, r, i, o) {retourne r &&! r [y] && (r = bt (r)) , i &&! i [y] && (i = bt (i, o)), st (fonction (o, s, a, u) {var l, c, f, p = [], h = [], d = s.longueur, g = o || Ct (t || "*", a.nodeType? [a]: a, []), m =! e ||! o && t? g: xt (g, p, e, a, u), y = n? i || (o? e: d || r)? []: s: m; si (n && n (m, y, a, u), r) {l = xt (y, h), r (l, [], a, u), c = l.longueur; tandis que (c -) (f = l [c]) && (y [h [c]] =! (m [h [c]] = f))} si (o) {si (i || e) {si (i) {l = [], c = y.longueur; tandis que (c -) (f = y [c]) &&.push (m [c] = f); i (nul, y = [], l, u)} c = y.longueur;tandis que (c -) (f = y [c]) && (l = i? AppelF (o, f): p [c])> - 1 && (o [l] =! (s [l] = f))}} sinon y = xt (y === s? y.splice (d, y.length): y), i? i (null, s, y, u): H.apply (s, y )})} fonction wt (e) {var t, n, i, o = e.longueur, s = r.relative [e [0] .type], u = s || r.relative [""], l = s? 1: 0, c = yt (fonction (e) {retour e === t}, u,! 0), f = yt (fonction (e) {retour F.call (t, e)> -1}, u,! 0), p = [fonction (e, n, r) {retour! S && (r || n! == a) || ((t = n) .nodeType? C (e, n, r): f (e, n, r))}]; pour (; o> l; l ++) si (n = r.relatif [e [l] .type]) p = [yt (vt (p ), n)]; else {if (n = r.filter [e [l] .type] .apply (null, e [l]. Matches), n [y]) {pour (i = ++ l; o> i; i ++) if (r.relative [e [i]. type]) break; retourne bt (l> 1 && vt (p), l> 1 && mt (e.slice (0, l-1)). replace ( I, "$ 1"), n, i> l && wt (e.slice (l, i)), o> i && wt (e = e.slice (i)), o> i && mt (e))} p.push (n )} retour vt (p)} fonction Tt (e, t) {var i = 0, o = t.longueur> 0, s = e.longueur>0, u = fonction (u, l, f, p, h) {var d, g, m, y = [], v = 0, x = "0", b = u && [], T = null! = h, C = a, k = u || s && r.find.TAG ("*", h && l.parentNode || l), N = w + = null == C? 1: Math.random () || .1; pour (T && (a = l! ​​== c && l, n = i); null! = (d = k [x]); x ++) {si (s && d) {g = 0; tandis que (m = e [g ++]) si (m (d, l, f)) {p.push (d); pause} T && (w = N, n = ++ i)} o && ((d =! m && d) && v -, u && b.push ( d))} if (v + = x, o && x! == v) {g = 0; tandis que (m = t [g ++)) m (b, y, l, f); if (u) {if (v> 0) tandis que (x -) b [x] || y [x] || (y [x] = Appel L (p)); y = xt (y)} H.apply (p, y), T &&! U && y.length> 0 && v + t.length> 1 && ut.uniqueSort (p)} retourne T && (w = N, a = C), b}; retourne o? St (u): u} s = ut.compile = fonction (e, t) {var n, r = [], i = [], o = N [e + ""]; si (! o) {t || (t = gt (e)), n = t .longueur; tandis que (n -) o = wt (t [n]), o [y]? r.push (o): i.push (o); o = N (e, Tt (i, r) )} retour o}; fonction Ct (e, t,n) {var r = 0, i = t.longueur; pour (; i> r; r ++) ut (e, t [r], n); retour n} fonction kt (e, t, n, i) { var o, a, u, l, c, f = gt (e); si (! i && 1 === f.length) {si (a = f [0] = f [0] .slice (0), a .length> 2 && "ID" === (u = a [0]). type && 9 === t.nodeType && p && r.relative [a [1] .type]) {if (t = (r.find.ID (u .matches [0] .replace (tt, nt), t) || []) [0],! t) retourne n; e = e.slice (a.shift (). value.length)} o = G .needsContext.test (e)? 0: a.length; tandis que (o -) {si (u = a [o], r.relative [l = type.Une]] se rompre; if ((c = r. find [l]) && (i = c (u.matches [0] .replace (tt, nt), X.test (un type [0].) && t.parentNode || t))) {if (a. splice (o, 1), e = i.length && mt (a),! e) retourne H.apply (n, i), n; pause}}} retourne s (e, f) (i, t,! p, n, X.test (e)), n} r.pseudos.nth = r.pseudos.eq; fonction Nt () {} Nt.prototype = r.filters = r.pseudos, r.setFilters = new Nt, b .sortStable = y.split (""). sort (S) .join ("") === y, l (), [0,0] .sort (S), b.detectDuplicates = E, at (function (e) {if (e.innerHTML = "<a href='#'> </a>", "#"! == e.firstChild.getAttribute ("href")) { var t = "type | href | hauteur | largeur" ​​.split ("|"), n = t.length; while (n -) r.attrHandle [t [n]] = ft}}, à (fonction (e) {if (null! = e.getAttribute ("désactivé")) {var t = P.split ("|"), n = t.length; tandis que (n -) r.attrHandle [t [n ]] = ct}}), x.find = ut, x.expr = ut.selectors, x.expr [":"] = x.expr.pseudos, x.unique = ut.uniqueSort, x.text = ut .getText, x.isXMLDoc = ut.isXML, x.contains = ut.contains} (e); var D = {}; fonction A (e) {var t = D [e] = {}; retourne x.each (e.match (w) || [], fonction (e, n) {t [n] =! 0}), t} x.Callbacks = fonction (e) {e = "chaîne" == typede e? D [e] || A (e): x.extend ({}, e); var t, n, r, i, o, s, a = [], u =! E.once && [], l = fonction (f) {pour (t = e.memory && f, n =! 0, s = i || 0, i = 0, o = une.longueur, r =! 0; a &&o> s; s ++) if (a [s] .apply (f [0], f [1]) ===! 1 && e.stopOnFalse) {t =! 1; break} r =! 1, a && (u? u.length && l (u.shift ()): t? a = []: c.disable ())}, c = {add: function () {if (a) {var n = a.length; (fonction s (t) {x.each (t, fonction (t, n) {var r = type x (n); "fonction" === r? e.unique && c.has (n) || a.push (n ): n && n.length && "chaîne"! == r && s (n)})}) (arguments), r? o = a.length: t && (i = n, l (t))} renvoie ceci}, remove: fonction () {retourne a && x.each (arguments, fonction (e, t) {var n; tant que ((n = x.inArray (t, a, n))>> - 1) a.splice (n, 1), r && (o> = n && o -, s> = n && s -)}, this}, a: function (e) {retour e? x.inArray (e, a)> - 1:! (! a ||! a.length)}, vide: function () {return a = [], o = 0, this}, désactiver: function () {return a = u = t = non défini, this}, désactivé: function () {return ! a}, lock: function () {return u = indéfini, t || c.disable (), this}, verrouillé:function () {return! u}, fireWith: function (e, t) {return t = t || [], t = [e, t.slice? t.slice (): t],! a || n && ! u || (r? u.push (t): l (t)), this}, fire: function () {return c.fireWith (this, arguments), this}, déclenché: function () {return! ! n}}; retourne c}, x.extend ({Différé: fonction (e) {var t = [["résoudre", "fait", x.Callbacks ("une fois en mémoire"), "résolu"], [ "rejeter", "échouer", x.Callbacks ("une fois en mémoire"), "rejeté"], ["notifier", "progression", x.Callbacks ("mémoire")]], n = "en attente", r = {state: function () {return n}, always: function () {return i.done (arguments) .fail (arguments), this}, alors: function () {var e = arguments; renvoie x.Deferred ( fonction (n) {x.each (t, fonction (t, o) {var s = o [0], a = x.isFonction (e [t]) && e [t]; i [o [1]] ( function () {var e = a && a.apply (this, arguments); e && x.isFunction (e.promise)? e.promise (). done (n.resolve) .fail (n.reject) .progress (n.notify): n [s + "Avec"] (this === r? n. promise (): ceci, a? [e]: arguments)})}, e = null}). promise ()}, promesse: fonction (e) {retour null! = e? x.extend (e, r ): r}}, i = {}; retourne r.pipe = r.alors, x.each (t, fonction (e, o) {var es = o [2], a = o [3]; r [ o [1]] = s.add, a && s.add (function () {n = a}, t [1 ^ e] [2] .disable, t [2] [2] .lock), i [o [ 0]] = function () {return i [o [0] + "avec"] (this === i? R: this, arguments), this}, i [o [0] + "avec"] = s .fireWith}), r.promise (i), e && e.call (i, i), i}, lorsque: fonction (e) {var t = 0, n = d.call (arguments), r = n.length , i = 1! == r || e && x.isFunction (e.promise)? r: 0, o = 1 === i? e: x.Deferred (), s = function (e, t, n) { fonction de retour (r) {t [e] = ceci, n [e] = arguments.longueur> 1? d.call (arguments): r, n === a? o.notifyWith (t, n): - i || o.resolveWith (t, n)}}, a, u, l; if (r> 1) pour (a = Tableau (r), u = Tableau (r), l = Tableau (r);r> t; t ++) n [t] && x.isFunction (n [t] .promise)? n [t] .promise (). done (s (t, l, n)). échec (o.réjecter). progrès (s (t, u, a)): - i; retourne i || o.resolveWith (l, n), o.promise ()}}), x.support = fonction (t) {var n = o.createElement ("input"), r = o.createDocumentFragment (), i = o.createElement ("div"), s = o.createElement ("select"), a = s.appendChild (o.createElement (" option ")); return n.type? (n.type =" case à cocher ", t.checkOn =" "! == n.valeur, t.optSelected = a.selected, t.reliableMarginRight =! 0, t.boxSizingReliable =! 0, t.pixelPosition =! 1, n.checked =! 0, t.noCloneChecked = n.cloneNode (! 0) .checked, s.disabled =! 0, t.optDisabled =! A.disabled, n = o.createElement ("input"), n.value = "t", n.type = "radio", t.radioValue = "t" === n.value, n.setAttribute ("coché", "t" ), n.setAttribute ("nom", "t"), r.appendChild (n), t.checkClone = r.cloneNode (! 0) .cloneNode (! 0) .lastChild.checked, t.focusinBubbles = "onfocusin" dans e, i.style.backgroundClip = "content- box ", i.cloneNode (! 0) .style.backgroundClip =" ", t.clearCloneStyle =" content-box "=== i.style.backgroundClip, x (fonction () {var n, r, s =" padding: 0; margin: 0; border: 0; display: block; -webkit-box-sizing: contenu-box; -moz-box-sizing: content-box; dimensionnement de box: content-box ", a = o .getElementsByTagName ("body") [0]; a && (n = o.createElement ("div"), n.style.cssText = "border: 0; width: 0; height: 0; position: absolute; haut: 0 ; left: -9999px; margin-top: 1px ", a.appendChild (n) .appendChild (i), i.innerHTML =" ", i.style.cssText =" - webkit-box-sizing: border-box; -moz-box-sizing: border-box; taille de la boîte: border-box; remplissage: 1px; border: 1px; affichage: bloc; largeur: 4px;margin-top: 1%; position: absolute; top: 1% ", x.swap (a, null! = a.style.zoom? {zoom: 1}: {}, function () {t.boxSizing = 4 === i.offsetWidth}), e.getComputedStyle && (t.pixelPosition = "1%"! == (e.getComputedStyle (i, null) || {}). top, t.boxSizingReliable = "4px" == = (e.getComputedStyle (i, null) || {width: "4px"}). width, r = i.appendChild (o.createElement ("div")), r.style.cssText = i.style.cssText = s, r.style.marginRight = r.style.width = "0", i.style.width = "1px", t.reliableMarginRight =! parseFloat ((e.getComputedStyle (r, null) || (}) .marginRight)), a.removeChild (n))}), t): t} ({}); var L, q, H = / (?: \ {[\ s \ S] * \} | \ [ [\ s \ S] * \]) $ /, O = / ([AZ]) / g; fonction F () {Object.defineProperty (this.cache = {}, 0, {get: function () {return {}}}), this.expando = x.expando + Math.random ()} F.uid = 1, F.accepts = function (e) {retourne e.nodeType? 1 === e.nodeType || 9 === e.nodeType:! 0}, F.prototype = {clé: fonction (e) {if (! F.accepts (e)) renvoie 0; var t = {}, n = e [ceci.expando]; if (! n) {n = F.uid ++; try {t [this.expando] = {valeur: n}, Object.defineProperties (e, t)} catch (r) {t [this.expando] = n, x.extend (e, t)}} retourne ceci .cache [n] || (this.cache [n] = {}), n}, ensemble: fonction (e, t, n) {varr, i = ceci.key (e), o = ceci.cache [i]; if ("chaîne" == typede t) o [t] = n; sinon si (x.isEmptyObject (o)) this.cache [i] = t; sinon pour (r dans t) o [r ] = t [r]}, get: fonction (e, t) {var n = this.cache [this.key (e)]; retourne t === non défini? n: n [t]}, accès: fonction (e, t, n) {retourne t === undefined || t && "chaîne" == typede t && n === undefined? this.get (e, t) :( this.set (e, t, n), n! == undefined? n: t)}, remove: function (e, t) {var n, r, i = ceci. clé (e), o = ceci.cache [i]; si (t === undefined) this.cache [i] = {}; sinon {x.isArray (t)? r = t.concat (t.map (x.camelCase)): t dans o? r = [t] :( r = x.camelCase (t), r = r dans o? [r]: r.match (w) || []), n = r.longueur;tandis que (n -) supprime o [r [n]]}}, hasData: fonction (e) {return! x.isEmptyObject (this.cache [e [this.expando]] || {})}, ignore: function (e) {delete this.cache [this.key (e)]}}, L = nouveau F, q = nouveau F, x.extend ({acceptData: F.accepts, hasData: function (e) {retour L .hasData (e) || q.hasData (e)}, données: fonction (e, t, n) {retour L.access (e, t, n)}, removeData: fonction (e, t) {L. remove (e, t)}, _données: fonction (e, t, n) {return q.access (e, t, n)}, _ removeData: fonction (e, t) {q.remove (e, t)} }), x.fn.extend ({data: function (e, t) {var n, r, i = ceci [0], o = 0, s = null; if (e === non défini) {if ( this.length && (s = L.get (i), 1 === i.nodeType &&! q.get (i, "hasDataAttrs"))) {pour (n = i.attributes; n.length> o; o ++) r = n [o] .name, 0 === r.indexOf ("data -") && (r = x.camelCase (r_substring (5)), P (i, r, s [r]) ; q.set (i, "hasDataAttrs",! 0)} retourne s} retourne "objet" == type de e? this.each (fonction () {L.set (this,e)}): x.access (this, function (t) {var n, r = x.camelCase (e); if (i && t === non défini) {if (n = L.get (i, e), n! == non défini) renvoie n; si (n = L.get (i, r), n! == non défini) renvoie n; si (n = P (i, r, non défini), n! == non défini) return n} else this.each (function () {var n = L.get (this, r); L.set (this, r, t), - 1! == e.indexOf ("-") && n! == undefined && L.set (this, e, t)}), null, t, arguments.length> 1, null,! 0)}, removeData: function (e) {retour this.each (function () {L .remove (this, e)})}}); fonction P (e, t, n) {var r; if (n === non défini && 1 === e.nodeType) if (r = "data -" + t .replace (O, "- $ 1"). toLowerCase (), n = e.getAttribute (r), "chaîne" == type de n) {try {n = "true" === n?! 0: "false "=== n?! 1:" null "=== n? null: + n +" "=== n? + n: H.test (n)? JSON.parse (n): n} attrape (i ) {} L.set (e, t, n)} sinon n = non défini; retourne n} x.extend ({file d'attente: fonction (e, t, n) {var r;retourne e? (t = (t || "fx") + "file d'attente", r = q.get (e, t), n && (! r || x.isArray (n)? r = q.access (e , t, x.makeArray (n)): r.push (n)), r || []): non défini}, file d'attente: fonction (e, t) {t = t || "fx"; var n = x.queue (e, t), r = longueur.n, i = n.shift (), o = x._queueHooks (e, t), s = fonction () {x.dequeue (e, t)}; "inprogress" === i && (i = n.shift (), r -), o.cur = i, i && ("fx" === t && n.unshift ("inprogress"), supprimez o.stop, i .call (e, s, o)),! r && o && o.empty.fire ()}, _ queueHooks: fonction (e, t) {var n = t + "queueHooks"; retourne q.get (e, n) || q .access (e, n, {vide: x.Callbacks ("une fois en mémoire"). add (function () {q.remove (e, [t + "file d'attente", n])})}}}), x .fn.extend ({file: function (e, t) {var n = 2; retourne "chaîne"! = typede e && (t = e, e = "fx", n -), n> arguments.length? x.queue (this [0], e): t === non défini? this: this.each (function () {var n = x.queue (this, e, t);
x._queueHooks (this, e), "fx" === e && "inprogress"! == n [0] && x.dequeue (this, e)})}, dequeue: function (e) {return this.each ( function () {x.dequeue (this, e)})}, délai: function (e, t) {retour e = x.fx? x.fx.speeds [e] || e: e, t = t | | "fx", this.queue (t, fonction (t, n) {var r = setTimeout (t, e); n.stop = fonction () {clearTimeout (r)}})}, clearQueue: fonction (e ) {retour this.queue (e || "fx", [])}, promesse: fonction (e, t) {var n, r = 1, i = x.Deferred (), o = ceci, s = ceci .length, a = fonction () {- r || i.resolveWith (o, [o])}; "chaîne"! = typede e && (t = e, e = indéfini), e = e || "fx "; tandis que (s -) n = q.get (o [s], e +" queueHooks "), n && n.empty && (r ++, n.empty.add (a)); renvoie a (), i.promise ( t)}}); var R, M, W = / [\ t \ r \ n] / g, $ = / \ r / g, B = / ^ (?: input | select | textarea | button) $ / i; x.fn.extend ({attr: fonction (e, t) {retourne x.access (this, x.attr, e, t, arguments.longueur> 1)}, removeAttr: function (e) {retourne this.each (function () {x.removeAttr (this, e)})}, prop: fonction (e, t) {return x.access (this, x.prop, e, t, arguments.length> 1)}, removeProp: function (e) {retour this.each (function () {delete this [x.propFix [e] || e}})}, addClass : fonction (e) {var t, n, r, i, o, s = 0, a = this.longueur, u = "chaîne" == typeof e && e; if (x.isFunction (e)) renvoie this.each (fonction (t) {x (this) .addClass (e.call (this, t, this.className))}); if (u) pour (t = (e || ""). match (w) | | []; a> s; s ++) if (n = ce [s], r = 1 === n.nodeType && (n.className? ("" + n.className + "") .replace (W, "" ): "")) {o = 0; tandis que (i = t [o ++]) 0> r.indexOf ("" + i + "") && (r + = i + ""); n.NomClasse = x.trim ( r)} retourne cette}, removeClass: fonction (e) {var t, n, r, i, o, s = 0, a = this.length, u = 0 === arguments.length || "chaîne"== typeof e && e; if (x.isFunction (e)) renvoie this.each (fonction (t) {x (this) .removeClass (e.call (this, t, this.className))}); if (u ) pour (t = (e || ""). match (w) || []; a> s; s ++) if (n = ce [s], r = 1 === n.nodeType && (n.className ? ("" + n.className + "") .replace (W, ""): "")) {o = 0; tandis que (i = t [o ++]) tandis que (r.indexOf ("" + i + "" )> = 0) r = r.remplace ("" + i + "", ""); n.className = e? X.trim (r): ""} renvoie ceci}, toggleClass: fonction (e, t) {var n = typede e, i = "booléen" == type de t; renvoyer x.isFonction (e)? this.each (fonction (n) {x (this) .toggleClass (e.call (this, n, this .className, t), t)}): this.each (function () {if ("string" === n) {var o, s = 0, a = x (cela), u = t, l = e.match (w) || []; tandis que (o = l [s ++]) u = i? u:! a.hasClass (o), un [u? "addClass": "removeClass"] (o)} else (n === r || "boolean "=== n) && (this.className && q.set (this," __ className __ ", this.className), this.className = this.className || e ===! 1?" ": q.get (this , "__ className __") || "")}), hasClass: function (e) {var t = "" + e + "", n = 0, r = this.length; pour (; r> n; n ++) if (1 === ce [n] .nodeType && ("" + ce [n]. nom de classe + "") .replace (W, "") .indexOf (t)> = 0) renvoie! 0; renvoie! 1} , val: function (e) {var t, n, r, i = ceci [0]; {if (arguments.length) renvoie r = x.isFunction (e), this.each (fonction (n) {var i , o = x (this); 1 === this.nodeType && (i = r? e.call (this, n, o.val ()): e, null == i? i = "": "numéro" == typeof i? i + = "": x.isArray (i) && (i = x.map (i, fonction (e) {return null == e? "": e + ""})), t = x .valHooks [this.type] || x.valHooks [this.nodeName.toLowerCase ()], t &&"set" dans t && t.set (this, i, "valeur")! == undefined || (this.value = i))}); if (i) renvoie t = x.valHooks [i.type] || x.valHooks [i.nodeName.toLowerCase ()], t && "get" dans t && (n = t.get (i, "valeur"))! == undefined? n: (n = i.value, "chaîne" == typeof n? n.replace ($, ""): null == n? "": n)}}}), x.extend ({valHooks: {option: {get: function (e) {var t = e.attributes.value; return! t || t.specified? e.value: e.text}}, sélectionnez: {get: function (e) {var t, n, r = e.options, i = e .selectedIndex, o = "select-one" === e.type || 0> i, s = o? null: [], a = o? i + 1: r.length, u = 0> i? a : o? i: 0; pour (; a> u; u ++) if (n = r [u],! (! n.selected && u! == i || (x.support.optDisabled? n.disabled: null!: null! == n.getAttribute ("disabled")) || n.parentNode.disabled && x.nodeName (n.parentNode, "optgroup"))) {if (t = x (n) .val (), o) retourne t; s.push (t)} retourne s}, set: fonction (e, t) {var n, r, i = e.options, o = x.makeArray (t), s = i.longueur; tandis que (s--) r = i [s], (r.selected = x.inArray (x (r) .val (), o)> = 0) && (n =! 0); retourne n || (e.selectedIndex = -1 ), o}}}, attr: fonction (e, t, n) {var i, o, s = e.nodeType; if (e && 3! == s && 8! == s && 2! == s) renvoie le typede e.getAttribute === r? x.prop (e, t, n) :( 1 === s && x.isXMLDoc (e) || (t = t.toLowerCase (), i = x.attrHooks [t] || (x .expr.match.boolean.test (t)? M: R)), n === non défini? i && "get" dans i && null! == (o = i.get (e, t))? o: (o = x.find.attr (e, t), null == o? undefined: o): null! == n? i && "set" dans i && (o = i.set (e, n, t))! = = non défini? o: (e.setAttribute (t, n + ""), n) :( x.removeAttr (e, t), indéfini))}, removeAttr: fonction (e, t) {var n, r, i = 0, o = t && t.match (w); si (o && 1 === e.nodeType) tandis que (n = o [i ++]) r = x.propFix [n] || n, x.expr.match.boolean .test (n) && (e [r] =! 1), e.removeAttribute (n)}, attrHooks: {type: {set: function (e, t) {if (! x.support.radioValue && "radio" = == t && x.nodeName (e, "entrée")) {var n = e.value; renvoyer e.setAttribute ("type", t), n && (e.value = n), t}}}}, propFix: {"for": "htmlFor", "class": "className"}, prop: function (e, t, n) {varr, i, o, s = e.nodeType; if (e && 3! == s && 8! == s && 2! == s) retourne o = 1! == s ||! x.isXMLDoc (e), o && (t = x.propFix [t] || t, i = x.propHooks [t]), n! == undefined? i && "set" dans i && (r = i.set (e, n, t))! == undefined? r: e [t] = n: i && "get" dans i && null! == ( r = i.get (e, t))? r: e [t]}, propHooks: {tabIndex: {get: function (e) {return e.hasAttribute ("tabindex") || B.test (e. nodeName) || e.href? e.tabIndex: -1}}}}), M = {set: fonction (e, t, n) {retourne t ===! 1? x.removeAttr (e, n): e.setAttribute (n, n), n}}, x.each (x.expr.match.boolean.source.match (/ \ w + / g), fonction (e, t) { var n = x.expr.attrHandle [t] || x.find.attr; x.expr.attrHandle [t] = fonction (e, t, r) {var i = x.expr.attrHandle [t], o = r? undefined: (x.expr.attrHandle [t] = undefined)! = n (e, t, r)? t.toLowerCase (): null; renvoyer x.expr.attrHandle [t] = i, o} }), x.support.optSelected || (x.propHooks.selected = {get: function (e) {var t = e.parentNode; renvoyer t && t.parentNode && t.parentNode.selectedIndex, null}}, x.each ( ["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {x.propFix [ this.toLowerCase ()] = this}), x.each (["radio", "case à cocher"], function () {x.valHooks [this] = {set: function (e, t) {retourne x.isArray (t)? e.checked = x.inArray (x (e) .val (), t)> = 0: non défini}}, x.support.checkOn || (x.valHooks [this] .get = function (e) {retour null === e.getAttribute ("valeur")? "sur": e.valeur})}); var I = / ^ clé /, z = / ^ (?: mouse | menu contextuel) | click /, _ = / ^ (?: focusinfocus | focusoutblur) $ /, X = / ^ ([^.] *) (?: \. (. +) |) $ /; fonction U () {return! 0 } fonction Y () {return! 1} fonction V () {try {return o.activeElement} capture (e) {}} x.event = {global: {}, ajouter: fonction (e, t, n, i , o) {var s, a, u, l, c, f, p, h, d, g, m, y = q.get (e); si (y) {n.handler && (s = n, n = s.handler, o = s.selector), n.guid || (n.guid = x.guid ++), (l = y.events) || (l = y.events = {}), (a = y.handle) || (a = y.handle = function (e) {return typeof x === r || e && x.event.triggered === e.type? undefined: x.event.dispatch.apply (a .elem, arguments)}, a.elem = e), t = (t || ""). match (w) || [""], c = t.length; tandis que (c -) u = X .exec (t [c]) || [], d = m = u [1], g = (u [2] || "") .split ("."). sort (), d && (p = x.événement.spécial [d] || {}, d = (o? p.delegateType: p.bindType) || d, p = x .event.special [d] || {}, f = x.extend ({type: d, origType: m, données: i, gestionnaire: n, guid: n.guid, sélecteur: o, needsContext: o && x.expr .match.needsContext.test (o), espace de noms: g.join (".")}, s), (h = l [d]) || (h = l [d] = [], h.delegateCount = 0, p.setup && p.setup.call (e, i, g, a)! ==! 1 || e.addEventListener && e.addEventListener (d, a,! 1)), p.add && (p.add.call ( e, f), f.handler.guid || (f.handler.guid = n.guid)), o? h.splice (h.delegateCount ++, 0, f): h.push (f), x.event .global [d] =! 0); e = null}}, remove: fonction (e, t, n, r, i) {var o, s, a, u, l, c, f, p, h, d, g, m = q.hasData (e) && q.get (e); if (m && (u = événements.m)) {t = (t || ""). match (w) || ["" ], l = t.length; tandis que (l -) si (a = X.exec (t [l]) || [], h = g = a [1], d = (a [2] || "") .split ("."). sort (), h) {f = x.event.spécial [h] || {}, h = (r? f.delegateType: f.bindType) || h, p = u [h] || [], a = a [2] && RegExp ("(^ | \ \.) "+ d.join (" \\. (?:. * \\. |) ") +" (\\. | $) "), s = o = p.length; while (o-- ) c = p [o],! i && g! == c.origType || n && n.guid! == c.guid || a &&! a.test (c.namespace) || r && r! == c.selector && (" ** "! == r ||! c.selector) || (p.splice (o, 1), c.selector && p.delegateCount -, f.remove && f.remove.call (e, c)); s &&! p.length && (f.teardown && f.teardown.call (e, d, m.handle)! ==! 1 || x.removeEvent (e, h, m.handle), supprimez u [h])} else pour ( h dans u) x.event.remove (e, h + t [l], n, r,! 0); x.isEmptyObject (u) && (supprimez m.handle, q.remove (e, "events") )}}, déclencheur: fonction (t, n, r, i) {var s, a, u, l, c, f, p, h = [r || o], d = y.call (t, " type ")? t.type: t, g = y.call (t," espace de nom ")? t.namespace.split (". "): [];if (a = u = r = r || o, 3! == r.nodeType && 8! == r.nodeType &&! _. test (d + x.event.triggered) && (d.indexOf (".")> = 0 && (g = d.split ("."), D = g.shift (), g.sort ()), c = 0> d.indexOf (":") && "sur" + d, t = t [x.expando]? t: new x.Event (d, "objet" == typede t && t), t.isTrigger = i? 2: 3, t.namespace = g.join ("."), t. namespace_re = t.namespace? RegExp ("(^ | \\.)" + g.join ("\\. (?:. * \\. |)") + "(\\. | $)"): null, t.result = undefined, t.target || (t.target = r), n = null == n? [t]: x.makeArray (n, [t]), p = x.event.special [d] || {}, i ||! p.trigger || p.trigger.apply (r, n)! ==! 1)) {if (! i &&! p.noBubble &&! x.isWindow (r) ) {pour (l = p.delegateType || d, _. test (l + d) || (a = a.parentNode); a; a = a.parentNode) h.push (a), u = a; u === (r.ownerDocument || o) && h.push (u.defaultView || u.parentWindow || e)} s = 0;while ((a = h [s ++]) &&! t.isPropagationStopped ()) t.type = s> 1? l: p.bindType || d, f = (q.get (a, "événements") || {}) [t.type] && q.get (a, "handle"), f && f.apply (a, n), f = c && a [c], f && x.acceptData (a) && f.apply && f.apply (a, n ) ===! 1 && t.preventDefault (); retourne t.type = d, i || t.isDefaultPrevented () || p._default && p._default.apply (h.pop (), n)! ==! 1 | |! x.acceptData (r) || c && x.isFunction (r [d]) &&! x.isWindow (r) && (u = r [c], u && (r [c] = null), x.event. triggered = d, r [d] (), x.event.triggered = non défini, u && (r [c] = u)), t.result}}, dispatch: fonction (e) {e = x.event.fix (e); var t, n, r, i, o, s = [], a = d.call (arguments), u = (q.get (this, "events") || {}) [e. type] || [], l = x.event.special [e.type] || {}; if (a [0] = e, e.delegateTarget = this,! l.preDispatch || l.preDispatch.call (this, e)! ==! 1) {s = x.event.handlers.call (this, e, u), t = 0; while ((i = s [t ++]) &&! e.isPropagationStopped ()) {e.currentTarget = i.elem, n = 0; while ((o = i .handlers [n ++]) &&! e.isImmediatePropagationStopped ()) (! e.namespace_re || e.namespace_re.test (o.namespace)) && (e.handleObj = o, e.data = o.data = o.data, r = ((x.event.special [o.origType] || {}) handle || o.handler) .apply (i.elem, a), r! == undefined && (e.result = r) === ! 1 && (e.preventDefault (), e.stopPropagation ()))} renvoie l.postDispatch && l.postDispatch.call (this, e), e.result}}, gestionnaires: function (e, t) {var n, r , i, o, s = [], a = t.delegateCount, u = e.target; if (a && u.nodeType && (! e.button || "clic"! = = e.type)) pour (; u! == this; u = u.parentNode || this) if (u.disabled! ==! 0 || "click"! == e.type) {pour (r = [], n = 0; a> n ; n ++) o = t [n], i = o.selecteur + "", r [i] === non défini && (r [i] = o.needsContext? x (i, this) .index (u)> = 0 : x.find (i,this, null, [u]). length), r [i] && r.push (o); r.length && s.push ({elem: u, handlers: r})} retourne t.length> a && s.push ({ elem: this, handlers: t.slice (a)}), s}, props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp qui" .split (""), fixHooks: {}, hookHooks: { props: "char charcode clé keyCode" .split (""), filtre: fonction (e, t) {retour null == e.which && (e.which = null! = t.charCode? t.charCode: t.keyCode ), e}}, mouseHooks: {props: "bouton boutons clientX clientY décalageX pageY pageY écranX écranY élémentElement" .split (""), filtre: fonction (e, t) {variable n, r, i, s = t .button; return null == e.pageX && null! = t.clientX && (n = e.target.ownerDocument ||, r = n.documentElement, i = n.body, e.pageX = t.clientX + (r && r.scrollLeft || i &&i.scrollLeft || 0) - (r && r.clientLeft || i && i.clientLeft || 0), e.pageY = t.clientY + (r && r.scrollTop || i && i.scrollTop || 0) - (r && r.clientTop || i && i .clientTop || 0)), e.which || s === undefined || (e.which = 1 & s? 1: 2 & s? 3: 4 & s? 2: 0), e}}, correction: fonction (e) {if (e [x.expando]) renvoie e; var t, n, r, i = type e, o = e, s = ceci.fixHooks [i]; s || (this.fixHooks [i] = s = z.test (i)? this.mouseHooks: I.test (i)? this.keyHooks: {}), r = s.props? this.props.concat (s.props): this.props, e = new x.Event (o), t = r.length; while (t -) n = r [t], e [n] = o [n]; retourne 3 === e.target.nodeType && (e .target = e.target.parentNode), s.filter? s.filter (e, o): e}, spécial: {load: {noBubble:! 0}, focus: {trigger: function () {retourne ceci! == V () && this.focus? (This.focus (),! 1): undefined}, delegateType: "focusin"}, flou: {trigger: function () {renvoie this === V () && this.blur ? (this.blur () ,! 1):undefined}, delegateType: "focusout"}, cliquez sur: {trigger: function () {return "checkbox" === this.type && this.click && x.nodeName (this, "input")? (this.click (),! 1 ): undefined}, _ default: function (e) {return x.nodeName (e.target, "a")}}, beforeunload: {postDispatch: function (e) {e.result! == undefined && (e.originalEvent. returnValue = e.result)}}}, simuler: fonction (e, t, n, r) {var i = x.extend (new x.Event, n, {type: e, isSimulated:! 0, originalEvent: { }}); r? x.event.trigger (i, null, t): x.event.dispatch.call (t, i), i.isDefaultPrevented () && n.preventDefault ()}}, x.removeEvent = fonction (e, t, n) {e.removeEventListener && e.removeEventListener (t, n,! 1)}, x.Event = function (e, t) {retourne cette instance de x.Event? (e && e.type? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || e.getPreventDefault && e.getPreventDefault ()? U: Y): this.type = e, t && x.extend (this, t), this.timeStamp = e && e.timeStamp || x.now (), this [x.expando] =! 0 , undefined): new x.Event (e, t)}, x.Event.prototype = {isDefaultPrevented: Y, isPropagationStopped: Y, isImmediatePropagationStopped: Y, preventDefault: function () {var e = this.originalEvent; this.isDefaultPrevented = U, e && e.preventDefault && e.preventDefault ()}, stopPropagation: function () {var e = this.originalEvent; this.isPropagationStopped = U, e & e.stopPropagation && e.stopPropagation ()}, stopImmental U, this.stopPropagation ()}}, x.each ({mouseenter: "mouseover", mouseleave: "mouseout"}, fonction (e, t) {x.event.special [e] = {delegateType: t, bindType : t, handle: fonction (e) {var n, r = ceci, i = e.relatedTarget, o = e.handleObj; return (! i || i! == r &&!! x.contient (r, i)) && (e.type = o.origType, n = o.handler.apply (this, arguments), e.type = t), n}}}), x.support.focusinBubbles || x.each ({focus: "focusin", flou: "focusout"}, fonction (e, t) {var n = 0, r = fonction (e) {x.event.simulate (t, e.target, x .event.fix (e),! 0)}; x.event.special [t] = {setup: function () {0 === n ++ && o.addEventListener (e, r,! 0)}, démontage : function () {0 === - n && o.removeEventListener (e, r,! 0)}}}), x.fn.extend ({on: function (e, t, n, r, i) {var if ("objet" == typede e) {"chaîne"! = typede t && (n = n || t, t = indéfini); pour (s dans e) ceci.on (s, t, n , e [s], i); retourne ceci} if (null == n && null == r? (r = t, n = t = indéfini): null == r && ("chaîne" == type de t? (r = n, n = non défini) :( r = n, n = t, t = non défini)), r ===! 1) r = Y; sinon si (! r) renvoie ceci; retourne 1 === i && (o = r, r = fonction (e) {retour x (). off (e), o.apply (ceci, arguments)}, r.guid = o.guid || (o.guid = x.guid ++)), this.each (function () {x.event.add (this, e, r, n, t)})}, un: function ( e, t, n, r) {renvoie this.on (e, t, n, r, 1)}, off: fonction (e, t, n) {var r, i; if (e && e.preventDefault && e.handleObj) return r = e.handleObj, x (e.delegateTarget) .off (r.nomspace? r.origType + "." + r.namespace: r.origType, r.selector, r.handler), ceci; if ("objet "== typeof e) {pour (i dans e) this.off (i, t, e [i]); retourne ceci} return (t ===! 1 ||" fonction "== typeof t) && ( n = t, t = non défini), n ===! 1 && (n = Y), this.each (fonction () {x.event.remove (this, e, n, t)})}, déclencheur: fonction (e, t) {retourne this.each (function () {x.event.trigger (e, t, this)})}, triggerHandler: function (e, t) {var n = this [0]; retourne n ? x.event.trigger (e, t, n,! 0): indéfini}}); var G = / ^. [^: # \ [\, \ *], $ /, J = x.expr.match. needsContext, Q = {enfants:! 0, contenu:! 0, suivant:! 0, prev:! 0}; x.fn.extend ({find:function (e) {var t, n, r, i = this.length; if ("chaîne"! = typeof e) retourne t = this, this.pushStack (x (e) .filter (function () {for ( r = 0; i> r; r ++) si (x.contient (t [r], ceci)), retournez! 0})); pour (n = [], r = 0; i> r; r ++) x. find (e, this [r], n); renvoie n = this.pushStack (i> 1? x.unique (n): n), n.selector = (this.selector? this.selector + "": "" ) + e, n}, a: fonction (e) {var t = x (e, ceci), n = t.longueur; retourne ceci.filtre (fonction () {var e = 0; pour (; n> e ; e ++) if (x.contains (this, t [e])) return! 0})}, pas: function (e) {return this.pushStack (Z (this, e || [],! 0)) }, filtre: fonction (e) {retourne this.pushStack (Z (ceci, e || [],! 1))}}, est: fonction (e) {retourne !! e && ("chaîne" == typeof e?? J.test (e)? X (e, this.context) .index (this [0])> = 0: x.filter (e, this) .length> 0: this.filter (e) .length> 0 )}, la plus proche: fonction (e, t) {var n, r = 0, i = longueur.no, longueur = o] [s, J.test (e) || "chaîne"! = typede e? x ( et || this.context): 0; pour (; i> r; r ++) pour (n = this [r]; n && n! == t; n = n.parentNode) if (11> n.nodeType && (s? s.index (n)> - 1: 1 === n.nodeType && x.find.matchesSelector (n, e))) {n = o.push (n); break} renvoie this.pushStack (o.length> 1 ? x.unique (o): o)}, index: fonction (e) {return e? "chaîne" == typede e? g.call (x (e), this [0]): g.call (this , e.jquery? e [0]: e): this [0] && this [0] .parentNode? this.first (). prevAll (). length: -1}, ajouter: function (e, t) {var n = "chaîne" == typede? x (e, t): x.makeArray (e && e.nodeType? [e]: e), r = x.merge (this.get (), n); renvoie ceci. pushStack (x.unique (r))}, addBack: function (e) {retourne this.add (null == e? this.prevObject: this.prevObject.filter (e))}}); fonction K (e, t) {while ((e = e [t]) && 1! == e.nodeType); retourne e} x.each ({parent: fonction (e) {var t = e.nodeparent; retourne t && 11! == t .nodeType? t: null}, parents:fonction (e) {return x.dir (e, "parentNode")}, parentsUntil: function (e, t, n) {return x.dir (e, "parentNode", n)}, ensuite: function (e) {return K (e, "nextSibling")}, prev: fonction (e) {return K (e, "previousSibling")}, nextAll: fonction (e) {return x.dir (e, "nextSibling")}, prevAll: function (e) {return x.dir (e, "previousSibling")}, nextUntil: function (e, t, n) {return x.dir (e, "nextSibling", n)}, prevUntil: function ( e, t, n) {return x.dir (e, "previousSibling", n)}, frères et soeurs: function (e) {return x.sibling ((e.parentNode || {}). firstChild, e)}, children: function (e) {return x.sibling (e.firstChild)}, contenu: function (e) {return x.nodeName (e, "iframe")? e.contentDocument || e.contentWindow.document: x. fusionner ([], e.childNodes)}}, fonction (e, t) {x.fn [e] = fonction (n, r) {var i = x.map (this, t, n); retourne "jusqu'au "! == e.slice (-5) && (r = n), r && "chaîne" == typede r && (i = x.filtre (r, i)), this.length> 1 && (Q [e] || x.unique (i), "p" === e [0] && i.reverse ()), this.pushStack (i)}}), x.extend ({filtre: fonction (e, t, n) {var r = t [0]; retourne n && (e = ": not (" + e + "") "), 1 === t.length && 1 === r.nodeType? x.find.matchesSelector (r, e)? [r]: []: x.find .matches (e, x.grep (t, fonction (e) {return 1 === e.nodeType}))}, dir: fonction (e, t, n) {var r = [], i = n! == undefined; while ((e = e [t]) && 9! == e.nodeType) if (1 === e.nodeType) {if (i && x (e) .is (n)) break; r.push (e)} return r}, frère: fonction (e, t) {var n = []; pour (; e; e = e.nextSibling) 1 === e.nodeType && e! == t && n.push (e) ; return n}}); fonction Z (e, t, n) {si (x.isFunction (t)) renvoie x.grep (e, fonction (e, r) {return !! t.call (e, r , e)! == n}); if (t.nodeType) renvoie x.grep (e, fonction (e) {retour e === t! == n}); if ("string "== typeof t) {if (G.test (t)) renvoie x.filter (t, e, n); t = x.filtre (t, e)} renvoie x.grep (e, fonction (e ) {retour g.call (t, e)> = 0! == n})} var et = / <(?! zone | br | col | embed | hr | img | entrée | lien | meta | param) ( ([\ w:] +) [^>] *) \ /> / gi, tt = / <([\ w:] +) /, nt = / <| & #? \ w +; /, rt = / <(?: script | style | link) / i, il = / ^ (?: case à cocher | radio) $ / i, ot = / vérifié \ s * (?: [^ =] | = \ s *. cochée. ) / i, st = / ^ $ | \ / (?: java | ecma) script / i, at = / ^ true \ / (. *) /, ut = / ^ \ s * <! (?: \ [ CDATA \ [| -) | (?: \] \] | -)> \ s * $ / g, lt = {option: [1, "<select multiple = 'multiple'>", "</ select > "], thead: [1," <table> "," </ table> "], tr: [2," <table> <tbody> "," </ tbody> </ table> "], td : [3, "<table> <tbody> <tr>", "</ tr> </ tbody> </ table>"], _ défaut: [0, "", ""]};lt.optgroup = lt.option, lt.tbody = lt.tfoot = lt.colgroup = lt.caption = lt.col = lt.thead, lt.th = lt.td, x.fn.extend ({text: function (e) {return x.access (this, function (e) {return e === undefined? x.text (this): this.empty (). append ((this [0] && this [0] .ownerDocument | | o) .createTextNode (e))}, null, e, arguments.length)}, append: function () {renvoie this.domManip (arguments, fonction (e) {if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {var t = ct (this, e); t.appendChild (e)}})}, par défaut: function () {return this.domManip ( arguments, fonction (e) {if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {var t = ct (this, e); t.insertBefore ( e, t.firstChild)}})}, avant: fonction () {retour this.domManip (arguments, fonction (e) {this.parentNode && this.parentNode.insertBefore (e, this)})}, après: function () {return this.domManip (arguments, fonction (e) {this.parentNode && this.parentNode.insertBefore (e, this.nextSibling)})}, supprimez: fonction (e, t) {var n, r = e? x.filter (e, this): this, i = 0; pour (; null! = ( n = r [i]); i ++) t || 1! == n.nodeType || x.cleanData (gt (n)), n.parentNode && (t && x.contains (n.ownerDocument, n) && ht (gt ( n, "script")), n.parentNode.removeChild (n)); retourne ceci}, vide: fonction () {var e, t = 0; pour (; null! = (e = this [t]); t ++) 1 === e.nodeType && (x.cleanData (gt (e,! 1)), e.textContent = ""); retourne ceci}, clone: ​​fonction (e, t) {retour e = null == e?! 1: e, t = null == t? e: t, this.map (fonction () {return x.clone (this, e, t)})}, html: function (e) {return x .access (this, fonction (e) {var t = this [0] || {}, n = 0, r = this.length; if (e === non défini && 1 === t.nodeType) renvoie t.innerHTML ; if ("string" == typede e &&! rt.test (e) &&! lt [(tt.exec (e) || ["", ""]) [1] .toLowerCase ()]) {e = e.replace (et, "<$ 1> </ $ 2>>"); try {for (; r> n; n ++) t = this [n] || {}, 1 === t.nodeType && (x.cleanData (gt (t,! 1)), t.innerHTML = e); t = 0} catch (i) {}} t && this.empty (). append (e)}, null, e, arguments.length)}, replaceWith: function () {var e = x.map (this , fonction (e) {return [e.nextSibling, e.parentNode]}), t = 0; retourne this.domManip (arguments, fonction (n) {var r = e [t ++], i = e [t ++]; i && (x (this) .remove (), i.insertBefore (n, r))},! 0), t? this: this.remove ()}, detach: function (e) {retourne ceci.remove (e ,! 0)}, domManip: fonction (e, t, n) {e = p.apply ([], e); varr, i, o, s, a, u, l = 0, c = ceci. longueur, f = ceci, h = c-1, d = e [0], g = x.isFonction (d); if (g ||! (1> = c || "chaîne"! = typeof d || x.support.checkClone) && ot.test (d)) retourne this.each (fonction (r) {var i = f.eq (r); g && (e [0] = d.call (this, r, i. html ())), i.domManip (e, t, n)}); if (c && (r = x.buildFragment (e, this [0] .ownDocument,! 1,! n && this), i = r.firstChild ,1 === r.childNodes.length && (r = i), i)) {pour (o = x.map (gt (r, "script"), ft), s = o.length; c> l; l ++ ) a = r, l! == h && (a = x.clone (a,! 0,! 0), s && x.merge (o, gt (a, "script"))), t.call (this [l ], a, l); if (s) pour (u = o [longueur.l.] .ownerDocument, x.map (o, pt), l = 0; s> l; l ++) a = o [l ], st.test (a.type || "") &&! q.access (a, "globalEval") && x.contains (u, a) && (a.src? x._evalUrl (a.src): x .globalEval (a.textContent.replace (ut, "")))} renvoyer ceci}}), x.each ({appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after ", replaceAll:" replaceWith "}, fonction (e, t) {x.fn [e] = fonction (e) {var n, r = [], i = x (e), o = i.longueur-1 , s = 0; pour (; o> = s; s ++) n = s === o? ceci: ceci.clone (! 0), x (i [s]) [t] (n), h.apply (r, n.get ()); renvoie this.pushStack (r)}}), x.extend ({clone: ​​function (e, t,n) {var r, i, o, s, a = e.cloneNode (! 0), u = x.contains (e.ownerDocument, e); if (! (x.support.noCloneChecked || 1! = = e.nodeType && 11! == e.nodeType || x.isXMLDoc (e))) pour (s = gt (a), o = gt (e), r = 0, i = o.longueur; i> r; r ++ ) mt (o [r], s [r]); si (t) si (n) pour (o = o || gt (e), s = s || gt (a), r = 0, i = o.length; i> r; r ++) dt (o [r], s [r]); sinon dt (e, a); retourne s = gt (a, "script"), s.longueur> 0 && ht (s ,! u && gt (e, "script")), a}, buildFragment: fonction (e, t, n, r) {var i, o, s, a, u, l, c = 0, f = e.length , p = t.createDocumentFragment (), h = []; pour (; f> c; c ++) if (i = e [c], i || 0 === i) if ("objet" === x .type (i)) x.merge (h, i.nodeType? [i]: i); sinon si (nt.test (i)) {o = o || p.appendChild (t.createElement ("div" )), s = (tt.exec (i) || ["", ""]) [1] .toLowerCase (), a = lt [s] || lt._default, o.innerHTML = a [1] + i.replace (et, "<$ 1> </ $ 2>") + a [2], l = a [0]; tandis que (l -) o = o.firstChild; x.fusion (h, o.childNodes), o = p.firstChild, o.textContent = ""} sinon h.push (t.createTextNode (i)); p.textContent = "", c = 0; while (i = h [c ++]) if ((! r || -1 === x.inArray (i, r)) && (u = x.contains (i.ownerDocument, i), o = gt (p.appendChild (i ), "script"), u && ht (o), n)) {l = 0; tandis que (i = o [l ++]) st.test (i.type || "") && n.push (i)} retourne p }, cleanData: fonction (e) {var t, n, r, i = longueur.e, = 0, s = x.événement.spécial; pour (; i> o; o ++) {si (n = e [ o], x.acceptData (n) && (t = q.access (n))) pour (r dans t.events) s [r]? x.event.remove (n, r): x.removeEvent (n , r, t.handle); L.discard (n), q.discard (n)}}, _ evalUrl: fonction (e) {return x.ajax ({url: e, type: "GET", dataType: " text ", async:! 1, global:! 1, success: x.globalEval})}}); function ct (e, t) {retourne x.nodeName (e," table ") && x.nodeName (1 == = t.nodeType? t: t.firstChild, "tr")? e.getElementsByTagName ("tbody") [0] || e.appendChild (e.ownerDocument.createElement ("tbody")): e} fonction ft (e) {return e.type = (null! == e.getAttribute (" type ")) +" / "+ type e, e} fonction pt (e) {var t = at.exec (type.e)); retourne t? e.type = t [1]: e.removeAttribute (" type "), e} fonction ht (e, t) {var n = longueur e, r = 0; pour (; n> r; r ++) q.set (e [r]," globalEval ",! t | | q.get (t [r], "globalEval"))} fonction dt (e, t) {var n, r, i, o, s, a, u, l; if (1 === t.nodeType ) {if (q.hasData (e) && (o = q.access (e), s = x.extend ({}, o), l = o.events, q.set (t, s), l) ) {delete s.handle, s.events = {}; pour (i dans l) pour (n = 0, r = 1 [longueur]; r> n; n ++) x. événement.add (t, i , l [i] [n])} L.hasData (e) && (a = L.access (e), u = x.extend ({}, a), L.set (t, u))}} fonction gt (e, t) {var n = e.getElementsByTagName? e.getElementsByTagName (t || "*"): e.querySelectorAll? e.querySelectorAll (t || "*"): []; retourne t === non défini || t && x.nodeName (e, t)? x.merge ([e], n): n} fonction mt (e, t) {var n = nom.noeud.toLowerCase (); "entrée" === n && it.test (type))? t.checked = e.checked :( "entrée" === n || "texte" == = n) && (t.defaultValue = e.defaultValue)} x.fn.extend ({wrapAll: fonction (e) {var t; retourne x.isFonction (e)? ceci (chaque fonction (t) {x ( this) .wrapAll (e.call (this, t))}) :( this [0] && (t = x (e, this [0] .ownerDocument) .eq (0) .clone (! 0), this [0] .parentNode && t.insertBefore (this [0]), t.map (function () {var e = this; while (e.firstElementChild) e = e.firstElementChild; renvoyer e}). Append (this)), this)}, wrapInner: function (e) {return x.isFunction (e)? this.each (fonction (t) {x (this) .wrapInner (e.call (this, t))}): this.each (function () {var t = x (this), n = t.contents (); n.length? n.wrapAll (e): t.append (e)})}, wrap:function (e) {var t = x.isFunction (e); renvoie this.each (fonction (n) {x (this) .wrapAll (t? e.call (this, n): e)})}, annule : function () {renvoie this.parent (). each (function () {x.NodeName (this, "body") || x (this) .replaceWith (this.childNodes)}). end ()}}) ; var yt, vt, xt = / ^ (aucun | table (?! - c [ea]). +) /, bt = / ^ marge /, wt = RegExp ("^ (" + b + ") (. * ) $ "," i "), Tt = RegExp (" ^ ("+ b +") (?! px) [az%] + $ "," i "), Ct = RegExp (" ^ ([+ -] ) = ("+ b +") "," i "), kt = {CORPS:" bloc "}, Nt = {position:" absolu ", visibilité:" masqué ", affichage:" bloc "}, Et = { letterSpacing: 0, fontWeight: 400}, St = ["Haut", "Droite", "Bas", "Gauche"], jt = ["Kit Web", "O", "Moz", "ms"]; fonction Dt (e, t) {si (t dans e) renvoie t; var n = t.charAt (0) .toUpperCase () + t.tranche (1), r = t, i = longueur jt; tandis que (i -) si (t = jt [i] + n, t dans e) retourne t; retourne r} fonction At (e, t) { renvoyer e = t || e, "none" === x.css (e, "display") ||! x.contains (e.ownerDocument, e)} fonction Lt (t) {return e.getComputedStyle (t , null)} fonction qt (e, t) {var n, r, i, o = [], s = 0, a = e.longueur; pour (; a> s; s ++) r = e [s], r.style && (o [s] = q.get (r, "olddisplay"), n = r.style.display, t? (o [s] || "none"! == n || (r.style .display = ""), "" === r.style.display && At (r) && (o [s] = q.access (r, "olddisplay", Pt (r.nodeNom)))): o [s ] || (i = At ​​(r), (n && "none"! == n ||! i) && q.set (r, "olddisplay", i? n: x.css (r, "display")) )); pour (s = 0; a> s ++) r = e [s], r.style && (t && "none"! == r.style.display && ""!! == r.style.display || (r.style.display = t? o [s] || "": "aucun ")); retour e} x.fn.extend ({css: fonction (e, t) {retour x.access (this, fonction (e, t, n) {var, i, o = {}, s = 0; si (x.isArray (t)) {pour (r = Lt (e), i = t.longueur; i> s ++) o [t [s]] = x.css (e, t [s],! 1, r); return o} return n! == non défini? x.style (e, t, n): x.css (e, t)}, e, t, arguments.length> 1 )}, show: function () {return qt (this,! 0)}, masquer: function () {return qt (this)}, bascule: function (e) {var t = "boolean" == typeof e; renvoyer this.each (function () {(t? e: At (this))? x (this) .show (): x (this) .hide ()}}}), x.extend ({cssHooks: {opacité: {get: fonction (e, t) {if (t) {var n = yt (e, "opacité"); retour "" === n? "1": n}}}}, cssNumber: {columnCount:! 0, fillOpacity:! 0, fontWeight:! 0, lineHeight:! 0, opacité:! 0, orphelin:! 0, veuve:! 0, zIndex:! 0, zoom:! 0}, cssProps: { "float": "cssFloat"}, style: function (e, t, n, r) {if (e && 3! == e.nodeType && 8! == e.nodeType && e.style) {var i, o, s, a = x.camelCase (t), u = e.style; retourne t = x.cssProps [a] || (x.cssProps [a] = Dt (u, a) ), s = x.cssHooks [t] || x.cssHooks [a], n === non défini? s && "get" dans s && (i = s.get (e,! 1, r))! == non défini ? i: u [t] :( o = typeof n, "chaîne" === o && (i = Ct.exec (n)) && (n = (i [1] +1) * i [2] + parseFloat (x.css (e, t)), o = "nombre"), null == n || "nombre" === o && isNaN (n) || ("nombre"! == o || x.cssNumber [ a] || (n + = "px"), x.support.clearCloneStyle || ""! == n || 0! == t.indexOf ("background") || (u [t] = "inherit" ), s && "set" dans s && (n = s.set (e, n, r)) === non défini || (u [t] = n)), non défini)}}, css: fonction (e, t , n, r) {var i, o, s, a = x.camelCase (t); retourne t = x.cssProps [a] || (x.cssProps [a] = Dt (e.style, a)) , s = x.cssHooks [t] || x.cssHooks [a], s && "get" dans s && (i = s.get (e,! 0, n)),i === non défini && (i = yt (e, t, r)), "normal" === i && t dans Et && (i = Et [t]), "" === n || n? (o = parseFloat (i), n ===! 0 || x.isNumeric (o)? o || 0: i): i}}), yt = fonction (e, t, n) {var r, i, o, s = n || Lt (e), a = s? s.getPropertyValue (t) || s [t]: indéfini, u = e.style; retourne s && (""! == a || x.contains ( e.ownerDocument, e) || (a = x.style (e, t)), Tt.test (a) && bt.test (t) && (r = u.width, i = u.minWidth, o = u .maxWidth, u.minWidth = u.maxWidth = u.width = a, a = s.width, u.width = r, u.minWidth = i, u.maxWidth = o)), a}; fonction Ht (e , t, n) {var r = wt.exec (t); retourne? Math.max (0, r [1] - (n || 0)) + (r [2] || "px"): t} fonction Ot (e, t, n, r, i) {var o = n === (r? "frontière": "contenu")? 4: "largeur" ​​=== t? 1: 0, s = 0; pour (; 4> o; o + = 2) "marge" === n && (s + = x.css (e, n + St [o],! 0, i)), r? ("Contenu" === n && (s- = x.css (e, "remplissage" + St [o],!0, i)), "marge"! == n && (s- = x.css (e, "bordure" + St [o] + "largeur",! 0, i))) :( s + = x.css (e, "remplissage" + St [o],! 0, i), "remplissage"! == n && (s + = x.css (e, "bordure" + St [o] + "largeur",! 0, i))); retourne la fonction} Ft (e, t, n) {var r =! 0, i = "largeur" ​​=== t? e.offsetWidth: e.offsetHeight, o = Lt (e), s = x.support.boxSizing && "border-box" === x.css (e, "boxSizing",! 1, o); if (0> = i || null == i) {if (i = yt ( e, t, o), (0> i || null == i) && (i = e.style [t]), Tt.test (i)) renvoie i; r = s && (x.support.boxSizingReliable | | i === e.style [t]), i = parseFloat (i) || 0} retourne i + Ot (e, t, n || (s? "frontière": "contenu"), r, o ) + "px"} fonction Pt (e) {var t = o, n = kt [e]; retourne n || (n = Rt (e, t), "aucune"! == n && n || (vt = (vt || x ("<iframe frameborder = '0' width = '0' height = '0 '/> "). Css (" cssText "," display: block! Important ")). AppendTo (t.documentElement), t = (vt [0] .contentWindow || vt [0] .contentDocument) .document , t.write ("<! doctype html> <html> <body>"), t.close (), n = Rt (e, t), vt.detach ()), kt [e] = n), n} fonction Rt (e, t) {var n = x (t.createElement (e)). appendTo (t.body), r = x.css (n [0], "display"); retourne n.remove (), r} x.each (["hauteur", "largeur"], fonction (e, t) {x.cssHooks [t] = {obtenir: fonction (e, n, r) {retour n? 0 = == e.offsetWidth && xt.test (x.css (e, "display"))? x.swap (e, Nt, fonction () {return Ft (e, t, r)}): Ft (e, t, r): undefined}, set: function (e, n, r) {var i = r && Lt (e); retourne Ht (e, n, r? Ot (e, t, r, x.support.boxSizing && "border- box "=== x.css (e," boxSizing ",! 1, i), i): 0)}}}), x (fonction () {x.support.reliableMarginRight || (x.cssHooks.marginRight = {get: function (e, t) {retour t? x.swap (e, {display: "bloc-en-ligne"}, yt, [e, "marginRight"]): non défini}}),! x. support.pixelPosition && x.fn.position && x.each (["haut", "gauche"], fonction (e, t) {x.cssHooks [t] = {obtenir: fonction (e, n) {retour n? (n = yt (e, t), Tt.test (n)? x (e) .position () [t] + "px": n): non défini}}})}), x.expr && x.expr.filters && (x .expr.filters.hidden = function (e) {return 0> = e.offsetWidth && 0> = e.offsetHeight}, x.expr.filters.visible = function (e) {return! x.expr.filters.hidden (e )}), x.each ({margin: "", padding: "", bordure: "Width"}, fonction (e, t) {x.cssHooks [e + t] = {expand: function (n) { var r = 0, i = {}, o = "chaîne" == type de n? n.split (""): [n]; pour (; 4> r; r ++) i [e + St [r] + t] = o [r] || o [r-2] || o [0]; renvoyer i}}, bt.test (e) || (x.cssHooks [e + t] .set = Ht)} )var Mt = /% 20 / g, Wt = / \ [\] $ /, $ t = / \ r? \ n / g, Bt = / ^ (?: soumettre | bouton | image | réinitialiser | fichier) $ / i, It = / ^ (?: input | select | textarea | keygen) /i;x.fn.extend ({serialize: function () {return x.param (this.serializeArray ())}, serializeArray: function ( ) {return this.map (function () {var e = x.prop (this, "elements"); retour e? x.makeArray (e): this}). filter (function () {var e = this. type; retournez this.name &&! x (this) .is (": disabled") && It.test (this.nodeName) &&! Bt.test (e) && (this.checked ||! it.test (e)) }). map (fonction (e, t) {var n = x (this) .val (); return null == n? null: x.isArray (n)? x.map (n, fonction (e) { return {name: t.name, valeur: e.replace ($ t, "\ r \ n")}}): {name: t.name, valeur: n.replace ($ t, "\ r \ n" )}}). get ()}}), x.param = fonction (e, t) {var n, r = [], i = fonction (e, t) {t = x.isFunction (t)? t (): null == t? "": t, r [longueur.ligne] = encodeurURIComponent (e) + "="+ encodeURIComponent (t)}; if (t === undefined && (t = x.ajaxSettings && x.ajaxSettings.traditional), x.isArray (e) || e.jquery &&! x.isPlainObject (e)) x.each (e) , function () {i (this.name, this.value)}); sinon pour (n dans e) zt (n, e [n], t, i); retourne r.join ("&"). remplacer (Mt, "+")}; fonction zt (e, t, n, r) {var i; si (x.isArray (t)) x.each (t, fonction (t, i) {n || Wt .test (e)? r (e, i): zt (e + "[" + ("objet" = = typede i? t: "") + "], i, n, r)}); sinon si (n || "objet"! == x.type (t)) r (e, t); sinon pour (i dans t) zt (e + "[" + i + "]", t [i], n, r)} x.each ("blur focus focusin focusout charger redimensionner défiler défiler cliquer sur dblclick mousedown mousedown mousemove mouseover mouseout mouseenter modification mouseleave modifier sélectionner envoyer touche de bascule appuyer sur contextuelmenu" .split (""), fonction (e, t) {x. fn [t] = fonction (e,n) {return arguments.length> 0? this.on (t, null, e, n): this.trigger (t)}}), x.fn.extend ({survol: fonction (e, t) {return this.mouseenter (e) .mouseleave (t || e)}, bind: fonction (e, t, n) {retourne this.on (e, null, t, n)}, unbind: fonction (e, t) {return this.off (e, null, t)}, delegate: function (e, t, n, r) {return this.on (t, e, n, r)}, undelegate: function (e, t, n) {return 1 === arguments.length? this.off (e, "**"): this.off (t, e || "**", n)}}); var _t, Xt, Ut = x.now (), Yt = / \? /, Vt = / #. * $ /, Gt = / ([? &]) _ = [^ &] * /, Jt = / ^ (. *?) : [\ t] * ([^ \ r \ n] *) $ / gm, Qt = / ^ (?: à propos de | app | app-storage |. + - extension | fichier | res | widget): $ /, Kt = / ^ (?: GET | HEAD) $ /, Zt = / ^ \ / \ //, en = / ^ ([\ w. + -] +:) (?: \ / \ / ([^ \ /?#:]*)(?::((d+)|)|)/,tn=x.fn.load,nn={{,rn={Name,on="*/".concat("* "); essayez {Xt = i.href} catch (sn) {Xt = o.createElement (" a "), Xt.href =" ", Xt = Xt.href} _t = en.exec (Xt.toLowerCase ( )) || [];function an (e) {return function (t, n) {"chaîne"! = typede t && (n = t, t = "*"); var, i = 0, o = t.toLowerCase (). match ( w) || [];
if (x.isFunction (n)) tandis que (r = o [i ++]) "+" === r [0]? (r = r.slice (1) || "*", (e [r] = e [r] || []). unshift (n)) :( e [r] = e [r] || []). push (n)}} fonction un (e, t, n, r) { var i = {}, o = e === rn; fonction s (a) {var u; renvoyer i [a] =! 0, x.each (e [a] || [], fonction (e, a ) {var l = a (t, n, r); retourne "chaîne"! = typede l || o || i [l]? o?! (u = l): non défini: (t.dataTypes.unshift ( l), s (l),! 1)}), u} retourne s (t.dataTypes [0]) ||! i ["*"] && s ("*")} fonction ln (e, t) { var n, r, i = x.ajaxSettings.flatOptions || {}; pour (n in t) t [n]! == undefined && ((i [n]? e: r || (r = {})) [n] = t [n]); retourne r && x.extend (! 0, e, r), e} x.fn.load = fonction (e, t, n) {if ("chaîne"! = = typede e && tn) retourne tn.apply (this, arguments); varr, i, o, s = ceci, a = e.indexOf (""); retourne a> = 0 && (r = e.slice (a), e = e. tranche (0, a)), x.isFunction (t)? (n = t, t = indéfini): t && "objet"== typede t && (i = "POST"), longueur> 0 && x.ajax ({url: e, type: i, type de données: "html", données: t}). done (fonction (e) {o = arguments, s.html (r? x ("<div>"). append (x.parseHTML (e)). find (r): e)}) complet (n && fonction (e, t) {s.each ( n, o || [e.responseText, t, e])}), this}, x.each (["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"] , fonction (e, t) {x.fn [t] = fonction (e) {retourne this.on (t, e)}}), x.extend ({actif: 0, dernier modifié: {}, etag: { }, ajaxSettings: {url: Xt, tapez: "GET", isLocal: Qt.test (_t [1]), global:! 0, processData:! 0, async:! 0, contentType: "application / x-www -form-urlencoded; charset = UTF-8 "html (r? x ("<div>"). append (x.parseHTML (e)). find (r): e)}) complet (n && fonction (e, t) {s.each (n, o | | [e.responseText, t, e])}), this}, x.each (["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], fonction (e , t) {x.fn [t] = fonction (e) {retourne this.on (t, e)}}), x.extend ({actif: 0, dernier modifié: {}, etag: {}, ajaxSettings: {url: Xt, tapez: "GET", isLocal: Qt.test (_t [1]), global:! 0, processData:! 0, async:! 0, contentType: "application / x-www-form-urlencoded ; charset = UTF-8 "html (r? x ("<div>"). append (x.parseHTML (e)). find (r): e)}) complet (n && fonction (e, t) {s.each (n, o | | [e.responseText, t, e])}), this}, x.each (["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], fonction (e , t) {x.fn [t] = fonction (e) {retourne this.on (t, e)}}), x.extend ({actif: 0, dernier modifié: {}, etag: {}, ajaxSettings: {url: Xt, tapez: "GET", isLocal: Qt.test (_t [1]), global:! 0, processData:! 0, async:! 0, contentType: "application / x-www-form-urlencoded ; charset = UTF-8 "t) {x.fn [t] = fonction (e) {retourne this.on (t, e)}}), x.extend ({actif: 0, dernierModifié: {}, etag: {}, ajaxSettings: { url: Xt, tapez: "GET", isLocal: Qt.test (_t [1]), global:! 0, processData:! 0, async:! 0, contentType: "application / x-www-form-urlencoded; jeu de caractères = UTF-8 "t) {x.fn [t] = fonction (e) {retourne this.on (t, e)}}), x.extend ({actif: 0, dernierModifié: {}, etag: {}, ajaxSettings: { url: Xt, tapez: "GET", isLocal: Qt.test (_t [1]), global:! 0, processData:! 0, async:! 0, contentType: "application / x-www-form-urlencoded; jeu de caractères = UTF-8 ", accepte: {"*": on, texte: "text / plain", html: "text / html", xml: "application / xml, text / xml", json: "application / json, text / javascript"} , contenu: {xml: / xml /, html: / html /, json: / json /}, responseFields: {xml: "responseXML", text: "responseText", json: "responseJSON"}, convertisseurs: {"* text ": String," text html ":! 0," text json ": x.parseJSON," text xml ": x.parseXML}, flatOptions: {url:! 0, contexte:! 0}}, ajaxSetup: fonction (e, t) {retourne t? ln (ln (e, x.ajaxSettings), t): ln (x.ajaxSettings, e)}, ajaxPrefilter: an (nn), ajaxTransport: an (rn), ajax: fonction (e, t) {"objet" == typede e && (t = e, e = indéfini), t = t || {}; varn, r, i, o, s, a, u, l, c = x.ajaxSetup ({}, t), f = c.context || c, p = c.context && (f.nodeType || f.jquery)? x (f): x.event, h = x.Déféré ( ), d = x.Callbacks ("une fois en mémoire"), g = c.statusCode || {}, m = {}, y = {}, v = 0, b = "annulé", T = {readyState: 0, getResponseHeader: fonction (e) {var t; if (2 === v) {if (! O) {o = {}; tandis que (t = Jt.exec (i)) o [t [1] .toLowerCase ()] = t [2]} t = o [e.toLowerCase ()]} return null == t? null: t}, getAllResponseHeaders: function () {return 2 === v? i: null}, setRequestHeader: function (e, t) {var n = e .toLowerCase (); return v || (e = y [n] = y [n] || e, m [e] = t), this}, overrideMimeType: function (e) {return v || (c. mimeType = e), this}, statusCode: fonction (e) {var t; si (e) si (2> v) pour (t dans e) g [t] = [g [t], e [t]] ; sinon T. toujours (e [T.status]); retourne ceci}, abandonne: fonction (e) {var t = e || b; retourne n && n.abort (t), k (0, t), ceci} if (h.promise (T) .complete = d.add, T.success = T.done, T.error = T. échec, c.url = ((e || c.url || Xt) + "") .replace (Vt, ""). replace (Zt, _t [1] + "//"), c.type = t.method || t.type || c.method || c.type, c.dataTypes = x.trim (c.dataType || "*").toLowerCase (). match (w) || [""], null == c.crossDomain && (a = en.exec (c.url.toLowerCase ()), c.crossDomain =! (! a || a [1 ] === _ t [1] && a [2] === _ t [2] && (a [3] || ("http:" === a [1]? "80": "443")) = == (_ t [3] || ("http:" === _ t [1]? "80": "443")))), c.data && c.processData && "chaîne"! = typeof c.data && (c .data = x.param (c.data, c.traditional)), un (nn, c, t, T), 2 === v) renvoie T; u = c.global, u && 0 === x.active ++ && x.event.trigger ("ajaxStart"), c.type = c.type.toUpperCase (), c.hasContent =! Kt.test (c.type), r = c.url, c.hasContent || (c.data && (r = c.url + = (Yt.test (r)? "&": "?") + c.data, supprimez c.data), c.cache ===! 1 && (c.url = Gt.test (r)? R.replace (Gt, "$ 1 _ =" + Ut ++): r + (Yt.test (r)? "&": "?") + "_ =" + Ut ++)), c.ifModified && (x.lastModified [r] && T.setRequestHeader ("If-Modified-Since", x.lastModified [r]), x.etag [r] && T.setRequestHeader ("If-None-Match", x.etag [ r])), (c.data && c.hasContent && c.contentType! ==! 1 || t.contentType) && T.setRequestHeader ("Content-Type", c.contentType), T.setRequestHeader ("Accept", c.dataTypes [0] && c.accepts [c.dataTypes [0]]? C.accepts [c.dataTypes [0]] + ("*"! == c.dataTypes [0]? "," + Sur + "; q = 0.01 ":" "): c.accepts [" * "]); pour (l dans c.headers) T.setRequestHeader (l, c.headers [l]); if (c.beforeSend && (c.beforeSend.call (f, T, c) ===! 1 || 2 === v)) retourne T.abort (); b = "avorter"; pour (l dans {succès: 1, erreur: 1, complet: 1 }) T [l] (c [l]); if (n = un (rn, c, t, T)) {T.readyState = 1, u && p.trigger ("ajaxSend", [T, c]), c.async && c.timeout> 0 && (s = setTimeout (function () {T.abort ("timeout")}, c.timeout)); essayez {v = 1, n.send (m, k)} catch (C) { si (! (2> v)) jette C; k (-1, C)}} sinon k (-1, "Pas de transport"); fonction k (e, t, o, a) {var l, m, y, b, w, C = t; 2! == v && (v = 2, s && clearTimeout (s), n = non défini, i = a || "", T.readyState = e> 0? 4: 0, l = e> = 200 && 300> e || 304 === e, o && (b = cn (c, T, o)), b = fn (c, b, T, l), l? (c.ifModifié && (w = T.getResponseHeader ("Dernière modification"), w && (x.lastModified [r] = w), w = T.getResponseHeader ("etag"), w && (x.etag [r] = w)), 204 = == e? C = "nocontent": 304 === e? C = "non modifié" :( C = état b, m = b.data, y = erreur b, l =! y)) :( y = C, (e ||! C) && (C = "erreur", 0> e && (e = 0))), T.status = e, T.statusText = (t || C) + "", l ? h.resolveWith (f, [m, C, T]): h.rejectWith (f, [T, C, y]), T.statusCode (g), g = non défini, u && p.trigger (l? "ajaxSuccess": "ajaxError", [T, c, l: m: y]), d.fireWith (f, [T, C]), u && (p.trigger ("ajaxComplete", [T, c]), - x.active || x.event.trigger ("ajaxStop"))}} retourne T}, getJSON: fonction (e, t, n) {return x.get (e, t, n, "json")}, getScript: fonction (e, t) {return x.get (e, indéfini, t, "script")}}), x.each ( ["get", "post"], fonction (e, t) {x [t] = fonction (e, n, r, i) {retourne x.isFunction (n) && (i = i || r, r = n, n = non défini), x.ajax ({url: e, type: t, dataType: i, données: n, succès: r})}}); fonction cn (e, t, n) {var r , i, o, s, a = e.contents, u = e.dataTypes; while ("*" === u [0]) u.shift (), r === non défini && (r = e.mimeType | | t.getResponseHeader ("Type de contenu")); if (r) pour (i dans a) if (a [i] && a [i] .test (r)) {u.unshift (i); break} if (u [0] dans n) o = u [0]; sinon {pour (i dans n) {if (!u [0] || e.convertisseurs [i + "" + u [0]]) {o = i; pause} s || (s = i)} o = o || s} retour o? (o! = = u [0] && u.unshift (o), n [o]): non défini} fonction fn (e, t, n, r) {var i, o, s, a, u, l = {}, c = e.dataTypes.slice (); if (c [1]) pour (s dans e.converters) l [s.toLowerCase ()] = e.converters [s]; o = c.shift (); while (o ) if (e.responseFields [o] && (n [e.responseFields [o]] = t),! u && r && e.dataFilter && (t = e.dataFilter (t, e.dataType)), u = o, o = c .shift ()) if ("*" === o) o = u; sinon if ("*"! == u && u! == o) {si (s = l [u + "" + o] || l ["*" + o],! s) pour (i dans l) si (a = i.split (""), a [1] === o && (s = l [u + "" + a [0] ] || l ["*" + a [0]])) {s ===! 0? s = l [i]: l [i]! ==! 0 && (o = a [0], c. unshift (a [1])); break} if (s! ==! 0) if (s && e ["jette"]) t = s (t); sinon essayez {t = s (t)} catch (f) {return {état: "parsererror", erreur: s? f: "Aucune conversion de "+ u +" à "+ o}}} return {état:" succès ", données: t}} x.ajaxSetup ({accepte: {script:" texte / javascript, application / javascript, application / ecmascript, application / x-ecmascript "}, contenu: {script: / (?: java | ecma) script /}, convertisseurs: {" script de texte ": fonction (e) {retour x.globalEval (e), e}}} ), x.ajaxPrefilter ("script", fonction (e) {e.cache === non défini && (e.cache =! 1), e.crossDomain && (e.type = "GET")}), x.ajaxTransport ( "script", fonction (e) {if (e.crossDomain) {var t, n; retour {send: fonction (r, i) {t = x ("<script>")). prop ({async:! 0 , charset: e.scriptCharset, src: e.url}). on ("erreur de chargement", n = fonction (e) {t.remove (), n = null, e && i ("erreur" === e.type ? 404: 200, type e)}), o.head.appendChild (t [0])}, abort: function () {n && n ()}}}}); var pn = [],hn = / (=) \? (? = & | $) | \? \? /; x.ajaxSetup ({jsonp: "callback", jsonpCallback: function () {var e = pn.pop () || x .expando + "_" + Ut ++; retourne ce [e] =! 0, e}}), x.ajaxPrefilter ("json jsonp", fonction (t, n, r) {var i, o, s, a = t .jsonp! ==! 1 && (hn.test (t.url)? "url": "chaîne" == typede t.data &&! (t.contentType || ""). indexOf ("application / x-www- form-urlencoded ") && hn.test (t.data) &&" data "); renvoyer un ||" jsonp "=== t.dataTypes [0]? (i = t.jsonpCallback = x.isFunction (t.jsonpCallback )? t.jsonpCallback (): t.jsonpCallback, a? t [a] = t [a] .remplace (hn, "$ 1" + i): t.jsonp! ==! 1 && (t.url + = (Yt .test (t.url)? "&": "?") + t.jsonp + "=" + i), t.converters ["script json"] = function () {return s || x.error (i + "n'était pas appelé"), s [0]}, t.dataTypes [0] = "json ", o = e [i], e [i] = fonction () {s = arguments}, r.toujours (fonction () {e [i] = o, t [i] && (t.jsonpCallback = n .jsonpCallback, pn.push (i)), s && x.isFunction (o) && o (s [0]), s = o = indéfini}), "script"): indéfini}), x.ajaxSettings.xhr = fonction ( ) {try {return new XMLHttpRequest} catch (e) {}}; var dn = x.ajaxSettings.xhr (), gn = {0: 200,1223: 204}, mn = 0, yn = {}; e. ActiveXObject && x (e) .on ("décharger", function () {pour (modifier dans yn) yn [e] (); yn = non défini}), x.support.cors = !! dn && "withCredentials" dans dn, x.support.ajax = dn = !! dn, x.ajaxTransport (fonction (e) {var t; renvoyer x.support.cors || dn &&! e.crossDomain? {send: fonction (n, r) {var i , o, s = e.xhr (); if (s.open (type.e, e.url, e.async, e.username, e.password), e.xhrFields) pour (i dans e.xhrFields) s [i] = e.xhrFields [i]; e.mimeType && s.overrideMimeType && s.overrideMimeType (e.mimeType), e.crossDomain || n ["X-Requested-With"] || (n ["X-Requested-With"] = "XMLHttpRequest"); pour (i dans n) s.setRequestHeader (i, n [i]); t = fonction (e) {retourne fonction () {t && (supprime yn [o], t = s.onload = s.onerror = null, "abort" === e? s.abort (): "error" = == e? r (s.status || 404, s.statusText): r (gn [s.status] || s.status, s.statusText, "string" == typede s.responseText? {text: s .responseText}: undefined, s.getAllResponseHeaders ()))}}, s.onload = t (), s.onerror = t ("erreur"), t = yn [o = mn ++] = t ("annulation") , s.send (e.hasContent && e.data || null)}, abort: function () {t && t ()}}: undefined}); var vn, xn, bn = / ^ (?: basculer | afficher | masquer) $ /, wn = RegExp ("^ (?: ([+ -]) = |) (" + b + ") ([az%] *) $", "i"), Tn = / queueHooks $ /, Cn = [Dn], kn = {"*": [fonction (e, t) {var n, r, i = ceci.créer (e, t), o = wn.exec (t), s = i.cur (), a = + s || 0,u = 1, l = 20; si (o) {si (n = + o [2], r = o [3] || (x.cssNumber [e]? "": "px"), "px" ! == r && a) {a = x.css (i.elem, e,! 0) || n || 1; do u = u || ".5", a / = u, x.style (i. elem, e, a + r); tandis que (u! == (u = i.cur () / s) && 1! == u && - l)} i.unit = r, i.start = a, i. end = o [1]? a + (o [1] +1) * n: n} renvoyer i}]}; fonction Nn () {renvoyer setTimeout (fonction () {vn = non défini}), vn = x.now ()} function En (e, t) {x.each (t, fonction (t, n) {var r = (kn [t] || []). concat (kn ["*"]), i = 0, o = r.longueur; pour (; o> i; i ++) si (r [i] .call (e, t, n)) retour})} fonction Sn (e, t, n) {var r, i, o = 0, s = longueur de Cn, a = x.Deferred (). always (function () {delete u.elem}), u = function () {if (i) renvoie! 1; var t = vn || Nn (), n = Math.max (0, l.startTime + l.duration-t), r = n / l.duration || 0, o = 1-r, s = 0, u = l .tweens.length; pour (; u> s; s ++) l.tweens [s] .run (o); return a.notifyWith (e, [l, o, n]), 1> o && u? n: (a .resolveWith (e, [l]) ,! 1)}, l = a.promise ({elem:e, props: x.extend ({}, t), opts: x.extend (! 0, {specialEasing: {}}, n), originalProperties: t, originalOptions: n, heure de début: vn || Nn (), durée: durée, tweens: [], createTween: fonction (t, n) {var r = x.Tween (e, l.opts, t, n, l.opts.specialEasing [t] || l.opts .lever); retourner l.tweens.push (r), r}, arrêter: fonction (t) {var n = 0, r = t.l.tweens.length: 0; si (i) renvoyer ceci; pour ( i =! 0; r> n; n ++) l.tweens [n] .run (1); retourne t? a.resolveWith (e, [l, t]): a.rejectWith (e, [l, t] ), this}}), c = l.props; pour (jn (c, l.opts.specialEasing); s> o; o ++) if (r = Cn [o] .call (l, e, c, l .opts)) return r; return En (l, c), x.isFunction (l.opts.start) && l.opts.start.call (e, l), x.fx.timer (x.extend (u, {elem: e, anim: l, file: l.opts.queue})), l.progress (l.opts.progress) .done (l.opts.done, l.opts.complete) .fail (l. opts.fail) .always (l.opts.always)} function jn (e, t) {var n, r, i, o, s; pour (n dans e) si (r = x.camelCase (n), i = t [r], o = e [n], x.isArray (o) &&(i = o [1], o = e [n] = o [0]), n! == r && (e [r] = o, supprimez e [n]), s = x.cssHooks [r], s && "expand" dans s) {o = s.expand (o), supprimez e [r]; pour (n dans o) n dans e || (e [n] = o [n], t [n] = i)} sinon t [r] = i} x.Animation = x.extend (Sn, {tweener: fonction (e, t) {x.isFunction (e)? (t = e, e = ["*"] ): e = e.split (""); var n, r = 0, i = e.longueur; pour (; i> r; r ++) n = e [r], kn [n] = kn [n] || [], kn [n] .unshift (t)}, préfiltre: fonction (e, t) {t? Cn.unshift (e): Cn.push (e)}}); fonction Dn (e, t , n) {var r, i, o, s, a, u, l, c, f, p = ceci, h = e.style, d = {}, g = [], m = e.nodeType && At (e ); n.queue || (c = x._queueHooks (e, "fx"), null == c.unqueued && (c.unqueued = 0, f = c.empty.fire, c.empty.fire = fonction ( ) {c.unqueued || f ()}), c.unqueued ++, p.always (function () {p.always (function () {c.unqueued -, x.queue (e, "fx"). length || c.empty.fire ()})})), 1 === e.nodeType && ("height" in t || "width"dans t) && (n.overflow = [h.overflow, h.overflowX, h.overflowY], "inline" === x.css (e, "display") && "none" === x.css ( e, "float") && (h.display = "inline-block")), n.overflow && (h.overflow = "hidden", p. toujours (function () {h.overflow = n.overflow [0] , h.overflowX = n.overflow [1], h.overflowY = n.overflow [2]})), a = q.get (e, "fxshow"); pour (r dans t) si (o = t [r], bn.exec (o)) {if (efface t [r], u = u || "bascule" === o, o === (m? "masquer": "show")) { if ("show"! == o || a === undefined || a [r] === undefined) continue; m =! 0} g.push (r)} if (s = g.length) { a = q.get (e, "fxshow") || q.access (e, "fxshow", {}), "caché" dans un && (m = a.hidden), u && (a.hidden =! m) , m? x (e) .show (): p.done (fonction () {x (e) .hide ()}), p.done (fonction () {var t; q.remove (e, "fxshow ");pour (t dans d) style x (e, t, d [t])}; pour (r = 0; s> r; r ++) i = g [r], l = p.createTween (i, m ? a [i]: 0), d [i] = a [i] || x.style (e, i), i dans a || (a [i] = l.start, m && (l.end = l.start, l.start = "width" === i || "height" === i? 1: 0))}} fonction An (e, t, n, r, i) {retourne un nouvel An. prototype.init (e, t, n, r, i)} x.Tween = An, An.prototype = {constructeur: An, init: fonction (e, t, n, r, i, o) {this.elem = e, this.prop = n, this.easing = i || "swing", this.options = t, this.start = this.now = this.cur (), this.end = r, this.unit = o || (x.cssNumber [n]? "": "px")}, cur: function () {var e = An.propHooks [this.prop]; retourne e && e.get? e.get (ceci): An.propHooks._default.get (this)}, exécutez: function (e) {var t, n = Un.propHooks [this.prop]; renvoie this.pos = t = this.options.duration? X.easing [ ceci.easing] (e, this.options.duration * e, 0,1, this.options.duration): e, this.now = (this.end-this.start) * t + this.start, this. options.step && this.options.step.call (this.elem, this.now, this), n && n.set? n.set (this): An.propHooks._default.set (this), this}}, An.prototype.init .prototype = An.prototype, An.propHooks = {_ défaut: {get: fonction (e) {var t; retour null == e.elem [e.prop] || e.elem.style && null! = e.elem. style [e.prop]? (t = x.css (e.elem, e.prop, ""), t && "auto"! == t? t: 0): e.elem [e.prop]}, ensemble: fonction (e) {x.fx.step [e.prop]? x.fx.step [e.prop] (e): e.elem.style && (null! = e.elem.style [x.cssProps [e.prop]] || x.cssHooks [e.prop])? x.style (e.elem, e.prop, e.now + e.unit): e.elem [e.prop] = e. maintenant}}}, An.propHooks.scrollTop = An.propHooks.scrollLeft = {set: function (e) {e.elem.nodeType && e.elem.parentNode && (e.elem [e.prop] = e.now)}} , x.each (["bascule", "show", "masquer"], fonction (e, t) {var n = x.fn [t]; x.fn [t] = fonction (e, r, i ) {return null == e || "boolean "== type of e? n.apply (this, arguments): this.animate (Ln (t,! 0), e, r, i)}}), x.fn.extend ({fadeTo: function (e , t, n, r) {retourne this.filter (At) .css ("opacity", 0) .show (). end (). animate ({opacity: t}, e, n, r)}, animate : fonction (e, t, n, r) {var i = x.isEmptyObject (e), o = x.speed (t, n, r), s = fonction () {var t = Sn (this, x. extend ({}, e), o); s.finish = function () {t.stop (! 0)}, (i || q.get (this, "finish")) && t.stop (! 0) }; return s.finish = s, i || o.queue ===! 1? this.each (s): this.queue (o.queue, s)}, arrêtez: fonction (e, t, n) {var r = fonction (e) {var t = e.stop; supprime e.stop, t (n)}; retourne "chaîne"! = typede e && (n = t, t = e, e = indéfini), t && e ! ==! 1 && this.queue (e || "fx", []), this.each (fonction () {var t =! 0, i = null! = E && e + "queueHooks", o = x.timers, s = q.get (this); if (i) s [i] && s [i] .stop && r (s [i]); else pour (i dans s) s [i] && s [i].stop && Tn.test (i) && r (s [i]); pour (i = longueur de longueur; i -;) o [i] .elem! == this || null! = e && o [i] .queue! = = e || (o [i] .anim.stop (n), t =! 1, o.splice (i, 1)); (t ||! n) && x.dequeue (this, e)})} , finition: fonction (e) {retourne e! ==! 1 && (e = e || "fx"), this.each (fonction () {var t, n = q.get (this), r = n [ e + "file d'attente"], i = n [e + "queueHooks"], o = x.timers, s = r? r.length: 0; pour (n.finish =! 0, x.queue (this, e, [ ]), i && i.cur && i.cur.finish && i.cur.finish.call (this), t = o.length; t -;) o [t] .elem === ceci && o [t]. Queue === e && (o [t] .anim.stop (! 0), o.splice (t, 1)); pour (t = 0; s> t; t ++) r [t] && r [t] .finish && r [t]. finish.call (this); supprimer n.finish})}}); fonction Ln (e, t) {var n, r = {hauteur: e}, i = 0; pour (t = t? 1: 0; 4> i; i + = 2-t) n = St [i], r ["marge" + n] = r ["remplissage" + n] = e; retourne t && (r.opacité = r.width = e) , r} x.chacun ({slideDown: Ln ("show"), slideUp: Ln ("hide"), slideToggle: Ln ("bascule"), fadeIn: {opacity: "show"}, fadeOut: {opacity: "hide"}, fadeToggle: {opacity: "toggle"}}, fonction (e, t) {x.fn [e] = fonction (e, n, r) {retourne this.animate (t, e, n, r)}}) , x.speed = fonction (e, t, n) {var r = e && "objet" == typede e? x.extend ({}, e): {complet: n ||! n && t || x.isFunction ( e) && e, durée: e, assouplissement: n && t || t &&! x.isFunction (t) && t}; retourne r.duration = x.fx.off? 0: "nombre" == typeder.duration? r.duration : r.duration dans x.fx.speeds? x.fx.speeds [r.duration]: x.fx.speeds._default, (null == r.queue || r.queue ===! 0) && ( r.queue = "fx"), r.old = r.complete, r.complete = function () {x.isFunction (r.old) && r.old.call (this), r.queue && x.dequeue (this, r.file)}, r}, x.easing = {linéaire:fonction (e) {return e}, swing: fonction (e) {return.5-Math.cos (e * Math.PI) / 2}}, x.timers = [], x.fx = Un.prototype. init, x.fx.tick = function () {var e, t = x.timers, n = 0; pour (vn = x.now (); t.length> n; n ++) e = t [n], e () || t [n]! == e || t.splice (n -, 1); t.length || x.fx.stop (), vn = non défini}, x.fx.timer = fonction (e) {e () && x.timers.push (e) && x.fx.start ()}, x.fx.interval = 13, x.fx.start = fonction () {xn || (xn = setInterval (x.fx.tick, x.fx.interval))}, x.fx.stop = function () {clearInterval (xn), xn = null}, x.fx.speeds = {lent: 600, rapide: 200 , _default: 400}, x.fx.step = {}, x.expr && x.expr.filters && (x.expr.filters.animated = function (e) {retour x.grep (x.timers, function (t) { retourne e === t.elem}). length}), x.fn.offset = fonction (e) {if (arguments.length) renvoie e === undefined? this: this.each (fonction (t) { x.offset.setOffset (this, e, t)}; var t, n, i = this [0], o = {haut: 0, gauche: 0}, s = i && i.ownerDocument;if (s) retourne t = s.documentElement, x.contains (t, i)? (typede i.getBoundingClientRect! == r && (o = i.getBoundingClientRect ()), n = qn (s), {top: o .top + n.pageYOffset-t.clientTop, gauche: o.left + n.pageXOffset-t.clientLeft}): o}, x.offset = {setOffset: fonction (e, t, n) {var r, i , o, s, a, u, l, c = x.css (e, "position"), f = x (e), p = {}; "statique" === c && (e.style.position = "relative"), a = f.offset (), o = x.css (e, "haut"), u = x.css (e, "gauche"), l = ("absolu" === c | | "fixed" === c) && (o + u) .indexOf ("auto")> - 1, l? (r = f.position (), s = r.top, i = r.left): (s = parseFloat (o) || 0, i = parseFloat (u) || 0), x.isFunction (t) && (t = t.call (e, n, a)), null! = t.top && (p.top = t.top-a.top + s), null! = t.left && (p.left = t.left-a.left + i), "utiliser" dans t? t.using.call ( e, p): f.css (p)}}, x.fn.extend ({position: function () {if (this [0]) {var e,t, n = this [0], r = {top: 0, left: 0}; renvoie "fixed" === x.css (n, "position")? t = n.getBoundingClientRect () :( e = this.offsetParent (), t = this.offset (), x.nodeName (e [0], "html") || (r = e.offset ()), r.top + = x.css (e [0 ], "borderTopWidth",! 0), r.left + = x.css (e [0], "borderLeftWidth",! 0)), {top: t.top-r.top-x.css (n, " marginTop ",! 0), à gauche: t.left-r.left-x.css (n," marginLeft ",! 0)}}}, offsetParent: function () {retour this.map (function () {var e = this.offsetParent || s; while (e &&! x.nodeName (e, "html") && "statique" === x.css (e, "position")) e = e.offsetParent; retourne e | | s})}}), x.each ({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, fonction (t, n) {var r = "pageYOffset" === n; x.fn [t] = fonction (i) {retour x.access (this, fonction (t, i, o) {var s = qn (t); retour o === non défini? s? s [n]: t [i]:(s? s.scrollTo (r? e.pageXOffset: o, r? o: e.pageYOffset): t [i] = o, indéfini)}, t, i, arguments.length, null)}}); fonction qn (e) {return x.isWindow (e)? e: 9 === e.nodeType && e.defaultView} x.each ({Hauteur: "hauteur", Largeur: "largeur"}, fonction (e, t) { x.each ({padding: "inner" + e, contenu: t, "": "outer" + e}, fonction (n, r) {x.fn [r] = fonction (r, i) {var o = arguments.length && (n || "boolean"! = typeof r), s = n || (r ===! 0 || i ===! 0? "margin": "border"); retourne x. accès (this, fonction (t, n, r) {var i; renvoyer x.isWindow (t)? t.document.documentElement ["client" + e]: 9 === t.nodeType? (i = t. documentElement, Math.max (t.body ["scroll" + e], i ["scroll" + e], t.body ["offset" + e], i ["offset" + e], i ["client "+ e])): r === non défini? x.css (t, n, s): style x (t, n, r, s)}, t, o? r: non défini, o, null) }})}),X.fn.size = function () {return this.length}, x.fn.andSelf = x.fn.addBack, "objet" == typeof module && "objet" == typeof module.exports? module.exports = x: " function "== typeof define && define.amd && define (" jquery ", [], function () {return x})," objet "== typeof e &&" objet "== typeof e.document && (e.jQuery = e. $ = x)}) (fenêtre);
